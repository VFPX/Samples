*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="examples.dbf" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*


<TABLE>
	<MemoFile></MemoFile>
	<CodePage>1252</CodePage>
	<LastUpdate></LastUpdate>
	<Database></Database>
	<FileType>0x00000030</FileType>
	<FileType_Descrip>Visual FoxPro</FileType_Descrip>

	<FIELDS>
		<FIELD>
			<Name>XNAME</Name>
			<Type>C</Type>
			<Width>8</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>DESCRIPTIO</Name>
			<Type>M</Type>
			<Width>4</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>C_CODE</Name>
			<Type>M</Type>
			<Width>4</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>X_CODE</Name>
			<Type>M</Type>
			<Width>4</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>WIN</Name>
			<Type>L</Type>
			<Width>1</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>DOS</Name>
			<Type>L</Type>
			<Width>1</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.F.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
		<FIELD>
			<Name>BUILD</Name>
			<Type>M</Type>
			<Width>4</Width>
			<Decimals>0</Decimals>
			<Null>.F.</Null>
			<NoCPTran>.T.</NoCPTran>
			<Field_Valid_Exp></Field_Valid_Exp>
			<Field_Valid_Text></Field_Valid_Text>
			<Field_Default_Value></Field_Default_Value>
			<Table_Valid_Exp></Table_Valid_Exp>
			<Table_Valid_Text></Table_Valid_Text>
			<LongTableName></LongTableName>
			<Ins_Trig_Exp></Ins_Trig_Exp>
			<Upd_Trig_Exp></Upd_Trig_Exp>
			<Del_Trig_Exp></Del_Trig_Exp>
			<TableComment></TableComment>
			<Autoinc_Nextval>0</Autoinc_Nextval>
			<Autoinc_Step>0</Autoinc_Step>
		</FIELD>
	</FIELDS>



	<RECORDS>

		<RECORD>
			<XNAME>ACTIHAND</XNAME>
			<DESCRIPTIO><![CDATA[unsigned int _ActivateHandler(FPFI handler)

This example activates an event handler when the library is loaded.  The event handler just prints a message and lets FoxPro process the message as it would normally.  The event handler is deactivated when the library is unloaded.

Some more functional examples of event handling can be found in the EXAMPLES directory as EVENT.C and SWATCH.C.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

static int HandlerID;

//
//	This is the routine that is registered as an event handler.
//
FAR EventHandler(WHandle theWindow, EventRec FAR *ev)
{
	_PutStr("\nEventHandler() called.");
	return NO;	// event still needs to be handled by FoxPro
}

FAR Activate()
{
	HandlerID = _ActivateHandler(EventHandler);
	return 0;
}

//
//	When the library is unloaded we must deactivate the event handler
//	in a CALLONUNLOAD function.
//
FAR DeActivate()
{
	_DeActivateHandler(HandlerID);
	return 0;
}

FoxInfo myFoxInfo[] =
{
	{"ACTIVATE",  Activate,	CALLONLOAD, ""},
	{"DEACTIVATE", DeActivate, CALLONUNLOAD, ""}
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
WAIT TO dummy TIME 5
SET LIBRARY TO
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjU1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNTUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>ACTIIDLE</XNAME>
			<DESCRIPTIO><![CDATA[unsigned int _ActivateIdle(FPFI handler)

This example activates an idle event handler when the library is loaded.  The idle event handler just prints a message.  The idle event handler is deactivated when the library is unloaded.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

static unsigned IdlerID;

//
//	This is the routine that is registered as an idle event handler.
//
void FAR IdleHandler(WHandle wh, EventRec *ev)
{
	_PutStr("\nIdleHandler() called.");
}

void FAR Activate(ParamBlk FAR *parm)
{
	IdlerID = _ActivateIdle((FPFI) IdleHandler);
}

//
//	When the library is unloaded we must deactivate the idle event handler
//	in a CALLONUNLOAD function.
//
void FAR DeActivate(ParamBlk FAR *parm)
{
    _DeActivateIdle(IdlerID);
}

FoxInfo myFoxInfo[] =
{
	{"ACTIVATE",    (FPFI) Activate,   CALLONLOAD,     ""},
	{"DEACTIVATE",  (FPFI) DeActivate, CALLONUNLOAD,   ""}
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
WAIT TO dummy TIME 5
SET LIBRARY TO
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>ACTIMENU</XNAME>
			<DESCRIPTIO><![CDATA[unsigned int  _ActivateIdle(FPFI handler)

This example builds a popup style "non-modal" menu with three items.  _ActivateMenu() displays the menu.  This menu is non-modal in that interaction is not forced as with _MenuInteract().  Rather when the user makes a selection the _OnSelection() routine is called, the item selected is printed out to the screen, and the menu disposed of.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

static MENUID menuId;
static long nDidSelect=0;


void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

FAR onSelection(long menuId, long itemId)
{
	_PutStr("\nitemId = "); putLong(itemId);
	_Execute("clear events");
	nDidSelect = itemId;
	return 0;
}

void FAR DidSelect(ParamBlk FAR *parm)
{
	Value val;
	val.ev_long = nDidSelect;
	val.ev_type  = 'I';
	_RetVal(&val);
}

void FAR deactivateMenu(ParamBlk FAR *parm)
{
    _DeActivateMenu(menuId);
	_DisposeMenu(menuId);
}

void FAR activateMenu(ParamBlk FAR *parm)
{
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_ActivateMenu(menuId);
	_OnSelection(menuId, -1, onSelection);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) activateMenu, CALLONLOAD, ""},
	{"DIDSELECT", (FPFI) DidSelect, 0, ""},
	{"ONUNLOAD", (FPFI) deactivateMenu, CALLONUNLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
WAIT WINDOW "Make selection from menu." NOWAIT

READ EVENTS
SET LIBRARY TO
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjcxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>ALEN</XNAME>
			<DESCRIPTIO><![CDATA[long  _ALen(NTI nti, int mode)

This example provides an API routine for each of the three possible mode values.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR alenElem(ParamBlk FAR *parm)
{
	_RetInt(_ALen(parm->p[0].loc.l_NTI, AL_ELEMENTS), 10);
}

void FAR alenSub1(ParamBlk FAR *parm)
{
	_RetInt(_ALen(parm->p[0].loc.l_NTI, AL_SUBSCRIPT1), 10);
}

void FAR alenSub2(ParamBlk FAR *parm)
{
	_RetInt(_ALen(parm->p[0].loc.l_NTI, AL_SUBSCRIPT2), 10);
}

FoxInfo myFoxInfo[] =
{
	{"ALENELEM", (FPFI) alenElem, 1, "R"},
	{"ALENSUB1", (FPFI) alenSub1, 1, "R"},
	{"ALENSUB2", (FPFI) alenSub2, 1, "R"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};


]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DIMENSION a[10, 11]
? ALENELEM(@a)  && returns 110
? ALENSUB1(@a)  && returns 10
? ALENSUB2(@a)  && returns 11

DIMENSION b[3]
? ALENELEM(@b)  && returns 3
? ALENSUB1(@b)  && returns 3
? ALENSUB2(@b)  && returns 0; no second subscript

c = .F.
? ALENELEM(@c)  && returns -1 because variable "c" is not an array
? ALENSUB1(@c)  && returns -1 because variable "c" is not an array
? ALENSUB2(@c)  && returns -1 because variable "c" is not an array
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjY2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>ALLOCA</XNAME>
			<DESCRIPTIO><![CDATA[void FAR *  _Alloca(unsigned int size)

This example duplicates the functionality of the FoxPro function REPLICATE().  The temporary memory used to duplicate the character comes from _Alloca().
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR allocaEx(ParamBlk FAR *parm)
{
	char FAR *rep;
	char c = *(char *) _HandToPtr(parm->p[0].val.ev_handle);

	rep = _Alloca((int) parm->p[1].val.ev_long + 1);
	_MemFill(rep, c, (int) parm->p[1].val.ev_long);
    rep[parm->p[1].val.ev_long] = '\0';  // null terminate

	_RetChar(rep);
}

FoxInfo myFoxInfo[] =
{
	{"XREPLICATE", (FPFI) allocaEx, 2, "C,I"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
x = xREPLICATE("x", 120)
? x
? LEN(x)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTA4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMDguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>ALLOCHAN</XNAME>
			<DESCRIPTIO><![CDATA[MHANDLE  _AllocHand(unsigned int hsize)

In this example a character is replicated in memory supplied by _AllocHand().  The API function replToMH() returns the memory handle to FoxPro.  From FoxPro the memory handle is passed to API functions which expect a memory handle argument (passed as an integer, "I").]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

//
//	Replicate char argument to memory allocated with _AllocHand().
//	Return the memory handle to FoxPro.
//
void FAR replToMH(ParamBlk FAR *parm)
{
	char FAR *rep;
	char c = *(char *) _HandToPtr(parm->p[0].val.ev_handle);
	MHANDLE mh;

	if ((mh = _AllocHand((int) parm->p[1].val.ev_long + 1)) == 0)
	{
		_Error(182);  // "Insufficient memory"
    }
	_HLock(mh);
	rep = _HandToPtr(mh);
	_MemFill(rep, c, (int) parm->p[1].val.ev_long);
	rep[parm->p[1].val.ev_long] = '\0';  // null terminate
	_HUnLock(mh);

	_RetInt(mh, 10);
}

//
//	Returns characters in memory handle.  Argument in call from FoxPro
//	must be a valid FoxPro memory handle.
//
void FAR MHToFoxString(ParamBlk FAR *parm)
{
	char FAR *string;
	MHANDLE mh = parm->p[0].val.ev_long;

	_HLock(mh);
	string = _HandToPtr(mh);
	_RetChar(string);
	_HUnLock(mh);
}

//
//	Frees memory handle.  Argument in call from FoxPro must be a valid
//	FoxPro memory handle.
//
void FAR freeMH(ParamBlk FAR *parm)
{
	_FreeHand((MHANDLE) parm->p[0].val.ev_long);
}

FoxInfo myFoxInfo[] =
{
	{"REPLTOMH", (FPFI) replToMH, 2, "C,I"},
	{"MHTOFOX", (FPFI) MHToFoxString, 1, "I"},
	{"FREEMH", (FPFI) freeMH, 1, "I"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
mh = REPLTOMH("x", 120)
? MHTOFOX(mh)
? LEN(MHTOFOX(mh))
? MHTOFOX(mh)
= FREEMH(mh)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTg5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>ALLOMEMO</XNAME>
			<DESCRIPTIO><![CDATA[long  _AllocMemo(Locator FAR *fld, long size)

This example creates new memo field contents.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR newMemo(ParamBlk FAR *parm)
{

	Locator FAR *memoFldLoc;
	FCHAN fchMemo;
	int memoLen;
	long loc;

	if ((fchMemo = _MemoChan(-1)) == -1)
	{
		_UserError("_MemoChan() failed");
	}
    memoFldLoc = &parm->p[0].loc;
    memoLen = parm->p[1].val.ev_length;

    if ((loc = _AllocMemo(memoFldLoc, memoLen)) == -1)
	{
		_UserError("_AllocMemo() failed");
	}
    _FSeek(fchMemo, loc, FS_FROMBOF);
    _HLock(parm->p[1].val.ev_handle);
	_FWrite(fchMemo, _HandToPtr(parm->p[1].val.ev_handle), memoLen);
	_HUnLock(parm->p[1].val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"NEWMEMO", (FPFI) newMemo, 2, "R,C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
CREATE TABLE wMemo (memoField M)
APPEND BLANK
= NewMemo(@MemoField, "Hello, World.")
APPEND BLANK
= NewMemo(@MemoField, "Is this or is this ain't fun?")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTM4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMzguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>BPOINT</XNAME>
			<DESCRIPTIO><![CDATA[void  _BreakPoint(void)

This example includes the macro _BreakPoint() which places an INT 3 that debuggers recognize as a break point.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	int RetValue;

	_BreakPoint(); // debugger breaks execution here

    _HLock(parm->p[0].val.ev_handle);
	_HLock(parm->p[1].val.ev_handle);

	RetValue = _StrCmp(_HandToPtr(parm->p[0].val.ev_handle),
		_HandToPtr(parm->p[1].val.ev_handle));

	_RetInt(RetValue, 10); // does return control here

    _HUnLock(parm->p[0].val.ev_handle);
	_HUnLock(parm->p[1].val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"STRCMP", (FPFI) Example, 2, "C,C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjU5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNTkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>CNTITEMS</XNAME>
			<DESCRIPTIO><![CDATA[int  _CountItems(MENUID menuid)

This example creates a menu with three items and calls _CountItems() to show that it correctly states the number of items on the menu.  It then disposes of items and again calls _CountItems().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR CountItemsEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

    _ActivateMenu(menuId);
	_PutStr("\n_CountItems() ="); putLong(_CountItems(menuId));
	_Execute("WAIT");

	_DisposeItem(menuId, _GetItemId(menuId, 1));
	_PutStr("\n_CountItems() ="); putLong(_CountItems(menuId));
	_Execute("WAIT");

	_DisposeItem(menuId, _GetItemId(menuId, 0));
	_PutStr("\n_CountItems() ="); putLong(_CountItems(menuId));
	_Execute("WAIT");

    _DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) CountItemsEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjk4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyOTguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBAPPEND</XNAME>
			<DESCRIPTIO><![CDATA[int  _DBAppend(int workarea, int carryflag)

This example calls _DBAppend() to append a record to the DBF in the current work area.  The API library function takes a carry flag as a parameter (passed on to _DBAppend()) and the FoxPro example demonstrates it uses.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	int RetCode;
	if ((RetCode = _DBAppend(-1, (int) parm->p[0].val.ev_long)) < 0) {
		_Error(-RetCode);
	}
}
FoxInfo myFoxInfo[] = {
	{"DBAPPEND", (FPFI) Example, 1, "I"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest

SET CARRY ON
= DBAPPEND(-1)	&& SET CARRY is ON, so carry
SET CARRY OFF
= DBAPPEND(1)	&& carry regardless of SET CARRY
= DBAPPEND(-1)	&& SET CARRY is OFF, so no carry

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTQ5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNDkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBLOCK</XNAME>
			<DESCRIPTIO><![CDATA[int  _DBLock(int workarea, int what)

This example provides two API functions callable from FoxPro, XRLOCK() which locks the current record of the current work area and XFLOCK() which locks the DBF of the current work area.  XRLOCK() calls _DBLock(-1, DBL_RECORD) and XFLOCK() calls _DBLock(-1, DBL_FILE).
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR xLockRecord(ParamBlk FAR *parm)
{
	_DBLock(-1, DBL_RECORD);
}

void FAR xLockFile(ParamBlk FAR *parm)
{
	_DBLock(-1, DBL_FILE);
}

FoxInfo myFoxInfo[] =
{
	{"XRLOCK", (FPFI) xLockRecord, 0, ""},
	{"XFLOCK", (FPFI) xLockFile,   0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};


]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest
USE Test SHARED
GO 2
= XRLOCK()
LIST STAT  && shows that record #2 is locked
= XFLOCK()
LIST STAT  && shows that whole DBF is locked

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTkzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxOTMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBREAD</XNAME>
			<DESCRIPTIO><![CDATA[int  _DBRead(int workarea, long record)

This example provides similar functionality as the FoxPro command GO.  XGO(n) moves the current record pointer to n in the current work area.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_DBRead(-1, parm->p[0].val.ev_long);
}

FoxInfo myFoxInfo[] =
{
	{"XGO", (FPFI) Example, 1, "I"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest
USE Test SHARED
GO BOTTOM
? RECNO()
= XGO(2)
? RECNO()

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTc4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNzguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBRECCNT</XNAME>
			<DESCRIPTIO><![CDATA[long  _DBRecCount(int workarea)

This example calls _DBRecCount() for the DBF in the current work area.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_RetInt(_DBRecCount(-1), 10);
}
FoxInfo myFoxInfo[] = {
	{"DBRECCOUNT", (FPFI) Example, 0, ""},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest
? DBRECCOUNT()	&& call API routine
? RECCOUNT()	&& call built-in FoxPro function

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjQ3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNDcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBRECNO</XNAME>
			<DESCRIPTIO><![CDATA[long  _DBRecNo(int workarea)

This example provides similar functionality as the FoxPro function RECNO().
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_RetInt(_DBRecNo(-1), 10);
}
FoxInfo myFoxInfo[] =
{
	{"DBRECNO", (FPFI) Example, 0, ""},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest
GO 3
? DBRECNO()
GO 6
? DBRECNO()
USE
? DBRECNO()  && returns -119

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Jolly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
APPEND BLANK
REPLACE ABC WITH "Good golly"
APPEND BLANK
REPLACE ABC WITH "Four score and"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBREPLAC</XNAME>
			<DESCRIPTIO><![CDATA[int  _DBReplace(Locator FAR *fld, Value FAR *val)

This example duplicates some of the functionality of the FoxPro command REPLACE (but works strictly on a single record at a time).
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_RetInt(_DBReplace(&parm->p[0].loc, &parm->p[1].val), 10);
}
FoxInfo myFoxInfo[] = {
	{"DBREPLACE", (FPFI) Example, 2, "R,?"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest
? DBREPLACE(@ABC, "Hello, world.")
? DBREPLACE(@ABC, 2)  && returns -302 because field ABC is a character field

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBREWIND</XNAME>
			<DESCRIPTIO><![CDATA[long  _DBRewind(int workarea)

This example calls _DBRewind() for the DBF in the current work area.  This has the same effect as the FoxPro command GO TOP.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_RetInt(_DBRewind(-1), 10);
}
FoxInfo myFoxInfo[] = {
	{"DBREWIND", (FPFI) Example, 0, ""},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest
GO BOTTOM
? RECNO()
? DBREWIND()	&& returns 1
? RECNO()		&& yes, we're at record 1

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjIxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMjEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBSEEK</XNAME>
			<DESCRIPTIO><![CDATA[long  _DBSeek(Value FAR *val)

This example performs a seek on whatever index controls the order of the DBF in the current work area.  Note the use of "?" in the FoxInfo structure which is required because we don't know the type of the index expression.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_DBSeek(&parm->p[0].val);
}
FoxInfo myFoxInfo[] = {
	{"DBSEEK", (FPFI) Example, 1, "?"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest

INDEX ON ABC TAG ABC
SET ORDER TO TAG ABC
= DBSEEK("Hello, world")  && seeks ABC = "Hello, world"
LIST NEXT 1
USE

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTIyLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMjIuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBSKIP</XNAME>
			<DESCRIPTIO><![CDATA[long  _DBSkip(int workarea, long distance)

This example duplicates the functionality of the FoxPro SKIP command.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *pblk)
{
	int RetCode;

    if ((RetCode = _DBSkip(-1, pblk->p[0].val.ev_long)) < 0) {
		_PutStr("\nError encountered in example program.");
        _Error(-RetCode);  // _DBSkip() returns negative error code
	}
	_RetInt(RetCode, 10);
}
FoxInfo myFoxInfo[] = {
	{"DBSKIP", (FPFI) Example, 1, "I"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
ON ERROR DO expectError
DO CreateTest
USE
= DBSKIP(1) 	&& _Error() called: no DBF in use
USE test
GO TOP
= DBSKIP(-1)
= DBSKIP(-1)	&& _Error() called: at top of file
GO BOTT
= DBSKIP(1)
= DBSKIP(1) 	&& _Error() called: at bottom of file
ON ERROR

PROCEDURE expectError
? "ERROR: " + MESSAGE()
RETURN

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjM2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBSTATUS</XNAME>
			<DESCRIPTIO><![CDATA[int  _DBStatus(int workarea)

This example displays the status of the DBF in the current work area.  It checks each bit of information in value returned by _DBStatus() and displays an appropriate message to the screen.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	int dbstatus = _DBStatus(-1);
	_PutStr("\nStatus of DBF in current work area:");
    if (dbstatus & DB_BOF)
		_PutStr("\nBOF()");
	if (dbstatus & DB_EOF)
		_PutStr("\nEOF()");
	if (dbstatus & DB_RLOCKED)
		_PutStr("\nCurrent record is RLOCKed");
	if (dbstatus & DB_FLOCKED)
		_PutStr("\nDatabase is FLOCKed");
	if (dbstatus & DB_EXCLUSIVE)
		_PutStr("\nDatabase is open EXCLUSIVEly");
	if (dbstatus & DB_READONLY)
		_PutStr("\nDatabase is READONLY");
}
FoxInfo myFoxInfo[] = {
	{"DBSTATUS", (FPFI) Example, 0, ""},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= DBSTATUS()  && displays status of DBF in current work area
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjgyLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODIuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBUNLOCK</XNAME>
			<DESCRIPTIO><![CDATA[void  _DBUnlock(int workarea)

This example uses _DBUnLock() to unlock all records of the DBF in the current work area.  The FoxPro code demonstrates it and verifies that it is working properly.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR xLockRecord(ParamBlk FAR *parm)
{
	_DBLock(-1, DBL_RECORD);
}
void FAR xLockFile(ParamBlk FAR *parm)
{
	_DBLock(-1, DBL_FILE);
}
void FAR xUnLockFile(ParamBlk FAR *parm)
{
	_DBUnLock(-1);
}
FoxInfo myFoxInfo[] = {
	{"XRLOCK",  (FPFI) xLockRecord, 0, ""},
	{"XFLOCK",  (FPFI) xLockFile,   0, ""},
	{"XUNLOCK", (FPFI) xUnLockFile, 0, ""},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};


]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest
USE Test SHARED
GO 2
= XRLOCK()
LIST STAT  && shows that record #2 is locked
= XUNLOCK()
LIST STAT  && shows no records are locked
= XFLOCK()
LIST STAT  && shows that whole DBF is locked
= XUNLOCK()
LIST STAT  && shows no records are locked

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjE1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMTUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBUNWIND</XNAME>
			<DESCRIPTIO><![CDATA[long  _DBUnwind(int workarea)

This example calls _DBUnWind() for the DBF in the current work area.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_RetInt(_DBUnwind(-1), 10);
}
FoxInfo myFoxInfo[] = {
	{"DBUNWIND", (FPFI) Example, 0, ""},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};


]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest

? DBUNWIND()	&& returns new record #
SKIP
? EOF() 		&& now EOF() returns .T.

PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjQzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNDMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBWRITE</XNAME>
			<DESCRIPTIO><![CDATA[int  _DBWrite(int workarea)

This example does a _DBReplace() using the two calling parameters, one a DBF field passed by reference, the other a value of the appropriate type.  It does a LIST NEXT 1 before and after a call to _DBWrite().
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	int RetValue;

    if (RetValue = _DBReplace(&parm->p[0].loc, &parm->p[1].val)) {
		_UserError("\n_DBReplace() failed");
	}
	_Execute("LIST NEXT 1");
	if (RetValue = _DBWrite(-1)) {
		_Error(-RetValue);
	}
	_Execute("LIST NEXT 1");
}
FoxInfo myFoxInfo[] = {
	{"DBWRITE", (FPFI) Example, 2, "R,?"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjYwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DEACTHAN</XNAME>
			<DESCRIPTIO><![CDATA[void  _DeActivateHandler(unsigned int)

This example activates an event handler when the library is loaded.  The event handler just prints a message and lets FoxPro process the message as it would normally.  The event handler is deactivated when the library is unloaded.  As in this example, _DeActivateHandler() is usually called from a CALLONUNLOAD function.

Some more functional examples of event handling can be found in the EXAMPLES directory as EVENT.C and SWATCH.C.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

static int HandlerID;

//
//	This is the routine that is registered as an event handler.
//

FAR EventHandler(WHandle theWindow, EventRec FAR *ev)
{
	_PutStr("\nEventHandler() called.");
	return NO;	// event still needs to be handled by FoxPro
}

FAR Activate()
{
	HandlerID = _ActivateHandler(EventHandler);
	return 0;
}

//
//	When the library is unloaded we must deactivate the event handler
//	in a CALLONUNLOAD function.
//
FAR DeActivate()
{
	_DeActivateHandler(HandlerID);
	return 0;
}

FoxInfo myFoxInfo[] =
{
	{"ACTIVATE",  (FPFI) Activate, CALLONLOAD, ""},
	{"DEACTIVATE", (FPFI)  DeActivate, CALLONUNLOAD, ""}
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTE5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMTkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DEACTIDL</XNAME>
			<DESCRIPTIO><![CDATA[void  _DeActivateIdle(unsigned int)

This example activates an idle event handler when the library is loaded.  The idle event handler just prints a message.  The idle event handler is deactivated when the library is unloaded.  As in this example,  _DeActivateIdle() is usually called from a CALLONUNLOAD function.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

static unsigned IdlerID;

//
//	This is the routine that is registered as an idle event handler.
//
void FAR IdleHandler(WHandle wh, EventRec *ev)
{
	_PutStr("\nIdleHandler() called.");
}

void FAR Activate(ParamBlk FAR *parm)
{
	IdlerID = _ActivateIdle((FPFI) IdleHandler);
}

//
//	When the library is unloaded we must deactivate the idle event handler
//	in a CALLONUNLOAD function.
//
void FAR DeActivate(ParamBlk FAR *parm)
{
    _DeActivateIdle(IdlerID);
}

FoxInfo myFoxInfo[] =
{
	{"ACTIVATE",    (FPFI) Activate,   CALLONLOAD,     ""},
	{"DEACTIVATE",  (FPFI) DeActivate, CALLONUNLOAD,   ""}
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjI0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMjQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DEACTMEN</XNAME>
			<DESCRIPTIO><![CDATA[void  _DeActivateMenu(MENUID menuid)

This example activates and deactivates a menu several times.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR DeActMenuEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

    _ActivateMenu(menuId);
	_Execute("WAIT WINDOW 'Menu activated'");
	_DeActivateMenu(menuId);
	_Execute("WAIT WINDOW 'Menu deactivated'");
    _ActivateMenu(menuId);
	_Execute("WAIT WINDOW 'Menu activated'");
	_DeActivateMenu(menuId);
	_Execute("WAIT WINDOW 'Menu deactivated'");

	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) DeActMenuEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTQzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNDMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DEFAPROC</XNAME>
			<DESCRIPTIO><![CDATA[void  _DefaultProcess(EventRec FAR *event)

This example is a loop consisting of a call to _GetNextEvent() followed by a call to _DefaultProcess().  All events receive get their default processing.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	EventRec ev;
	int i;

	for (i = 0; i < 16; i++) {
		_GetNextEvent(&ev);
        _DefaultProcess(&ev);
	}
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI)Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DIALOG</XNAME>
			<DESCRIPTIO><![CDATA[int  _Dialog(int scheme, char FAR *body_text, char FAR *button1, char FAR *button2, char FAR*button3, int default, int escape)

This example creates dialogs with three, two, one, and no buttons.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR dialogEx(ParamBlk FAR *parm)
{
	int selection;

    selection = _Dialog(DIALOG_SCHEME, "Example dialog with 3 buttons.",
		"First", "Second", "Third", 2, 3);

	_PutStr("\nItem selected ="); putLong(selection);

	selection = _Dialog(DIALOG_SCHEME, "Example dialog with 2 buttons.",
		"First", "Second", 0, 2, 2);

	_PutStr("\nItem selected ="); putLong(selection);

	selection = _Dialog(DIALOG_SCHEME, "Example dialog with 1 button.",
		"First", (char *) 0, (char *) 0, 1, 1);

	_PutStr("\nItem selected ="); putLong(selection);

	selection = _Dialog(DIALOG_SCHEME, "Example dialog no buttons.",
		(char *) 0, (char *) 0, (char *) 0, 1, 2);

	_PutStr("\nItem selected ="); putLong(selection);
}

FoxInfo myFoxInfo[] =
{
	{"DIALOGEX", (FPFI) dialogEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwNzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DISPITEM</XNAME>
			<DESCRIPTIO><![CDATA[void  _DisposeItem(MENUID menuid, ITEMID itemid)

This example creates a menu with three items and then uses _DisposeItem() to remove two of the items.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR DisposeItemEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

    _ActivateMenu(menuId);
	_Execute("WAIT WINDOW 'Menu has three items'");

	_DisposeItem(menuId, _GetItemId(menuId, 1));
	_Execute("WAIT WINDOW 'Menu has two items'");

	_DisposeItem(menuId, _GetItemId(menuId, 0));
	_Execute("WAIT WINDOW 'Menu has one item'");

    _DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) DisposeItemEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjIwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMjAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DISPMENU</XNAME>
			<DESCRIPTIO><![CDATA[void  _DisposeMenu(MENUID menuid)

This example calls _DisposeMenu() after a menu selection has been made.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

FAR onSelection(long menuId, long itemId)
{
	_PutStr("\nitemId = "); putLong(itemId);
	_DisposeMenu(menuId);
	return 0;
}

void FAR activateMenu(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_ActivateMenu(menuId);
	_OnSelection(menuId, -1, onSelection);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) activateMenu, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjU4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNTguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDACTIVE</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdActive(WHANDLE, BOOL)

This example opens an edit window for a file whose name is passed as a parameter and selects the first character.  Using _EdActive() the example activates and then deactivates the selection.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR EdActiveEx(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
    _HLock(parm->p[0].val.ev_handle);
	pFILENAME[parm->p[0].val.ev_length] = '\0';
	wh = _EdOpenFile(pFILENAME, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);

    _EdSelect(wh, 0, 1);

	_EdActive(wh, TRUE);
	_Execute("WAIT 'Selection active'");

	_EdActive(wh, FALSE);
	_Execute("WAIT 'Selection inactive'");
}

FoxInfo myFoxInfo[] =
{
	{"EDACTIVE", (FPFI) EdActiveEx, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
fc = FCREATE("x", 0)
FOR i = 1 TO 90
	= FPUTS(fc, REPL(ALLT(STR(i)), i), i)
ENDFOR
= FCLOSE(fc)

= EDACTIVE("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDCLOSE</XNAME>
			<DESCRIPTIO><![CDATA[int  _EdCloseFile(WHANDLE, int)

This example opens a single file specified by a parameter for editing, deletes a character, and closes the edit session three times.  The first time _EdCloseFile() is called with "save without asking," the second time with "save with asking," and the third time with "save as."  Each time the return value of _EdCloseFile() is displayed.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 5;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	int retValue;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
    _HLock(parm->p[0].val.ev_handle);
	pFILENAME[parm->p[0].val.ev_length] = '\0';
//
//	Open, delete a character, close "save without asking"
//
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);

    _HUnLock(parm->p[0].val.ev_handle);

	_EdSelect(wh, 0, 1);
	_EdDelete(wh);
	retValue = _EdCloseFile(wh, 0); // save without asking
	_PutStr("\n_EdCloseFile() ="); putLong(retValue);
//
//	Open, delete a character, close "save with asking"
//
    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
    _HUnLock(parm->p[0].val.ev_handle);

	_EdSelect(wh, 0, 1);
	_EdDelete(wh);
	retValue = _EdCloseFile(wh, 1); // save with asking
	_PutStr("\n_EdCloseFile() ="); putLong(retValue);
//
//	Open, delete a character, close "save as"
//
    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
    _HUnLock(parm->p[0].val.ev_handle);

	_EdSelect(wh, 0, 1);
	_EdDelete(wh);
	retValue = _EdCloseFile(wh, 2); // save as
	_PutStr("\n_EdCloseFile() ="); putLong(retValue);
}

FoxInfo myFoxInfo[] =
{
	{"EDCLOSE", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDCLOSE("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDCOPY</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdCopy(WHANDLE)

This example opens a file specified by a parameter for editing, copies the first character to the clipboard using _EdCopy(), and pastes it after the second character using _EdPaste().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

    _EdSelect(wh, 0, 1);
	_EdCopy(wh);
	_EdSetPos(wh, 2);
	_EdPaste(wh);
}

FoxInfo myFoxInfo[] =
{
	{"EDCOPY", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDCOPY("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDCUT</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdCut(WHANDLE)

This example opens a file specified by a parameter for editing, cuts the first character to the clipboard using _EdCut(), and pastes it after the second character using _EdPaste().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

    _EdSelect(wh, 0, 1);
	_EdCut(wh);
	_EdSetPos(wh, 2);
	_EdPaste(wh);
}

FoxInfo myFoxInfo[] =
{
	{"EDCUT", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDCUT("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTc3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNzcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDDELETE</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdDelete(WHANDLE)

This example opens a file specified by a parameter for editing and deletes the first character in the file using _EdDelete().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
    _HUnLock(parm->p[0].val.ev_handle);

	_EdSelect(wh, 0, 1);
	_EdDelete(wh);
}

FoxInfo myFoxInfo[] =
{
	{"EDDELETE", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDDELETE("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjk4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyOTguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDGETCHA</XNAME>
			<DESCRIPTIO><![CDATA[TEXT  _EdGetChar(WHANDLE, EDPOS )

This example opens a file specified by a parameter for editing and displays to the screen the entire contents of the file.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDENV EdEnv;
	EDPOS edpos;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
    _HLock(parm->p[0].val.ev_handle);
	pFILENAME[parm->p[0].val.ev_length] = '\0';
	wh = _EdOpenFile(pFILENAME, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdGetEnv(wh, &EdEnv);

	for (edpos = 0; edpos <= EdEnv.length; edpos++)
	{
		_PutChr(_EdGetChar(wh, edpos));
	}
}

FoxInfo myFoxInfo[] =
{
	{"EDGETCHAR", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDGETCHAR("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDGETENV</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdGetEnv(WHANDLE, *EDENV)

This example opens an edit session for a file specified by a parameter and displays each field of the EDENV structure for that file as returned by _EdGetEnv().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(unsigned long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 6;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDENV EdEnv;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdGetEnv(wh, &EdEnv);

	_PutStr("\nfilename: ");        _PutStr(EdEnv.filename);
	_PutStr("\nlength: ");          putLong(EdEnv.length);
	_PutStr("\nlenLimit: ");        putLong(EdEnv.lenLimit);
	_PutStr("\ndirty: ");           putLong(EdEnv.dirty);
	_PutStr("\nautoIndent: ");      putLong(EdEnv.autoIndent);
	_PutStr("\nbackup: ");          putLong(EdEnv.backup);
	_PutStr("\naddLineFeeds: ");    putLong(EdEnv.addLineFeeds);
	_PutStr("\nautoCompile: ");     putLong(EdEnv.autoCompile);
	_PutStr("\naddCtrlZ: ");        putLong(EdEnv.addCtrlZ);
	_PutStr("\nsavePrefs: ");       putLong(EdEnv.savePrefs);
	_PutStr("\ndragAndDrop: ");     putLong(EdEnv.dragAndDrop);
	_PutStr("\nreadOnly: ");        putLong(EdEnv.readOnly);
	_PutStr("\nstatus: ");          putLong(EdEnv.status);
	_PutStr("\nlockPrefs: ");       putLong(EdEnv.lockPrefs);
	_PutStr("\ninsertMode: ");      putLong(EdEnv.insertMode);
	_PutStr("\nwrap: ");            putLong(EdEnv.wrap);
	_PutStr("\nselStart: ");        putLong(EdEnv.selStart);
	_PutStr("\nselEnd: ");          putLong(EdEnv.selEnd);
	_PutStr("\nselAnchor: ");       putLong(EdEnv.selAnchor);
	_PutStr("\njustMode: ");        putLong(EdEnv.justMode);
	_PutStr("\ntabWidth: ");        putLong(EdEnv.tabWidth);
	_PutStr("\nfontName: ");        _PutStr(EdEnv.fontName);
	_PutStr("\nfontSize: ");        putLong(EdEnv.fontSize);
	_PutStr("\nfontStyle: ");       putLong(EdEnv.fontStyle);
	_PutStr("\nkind: ");            putLong(EdEnv.kind);
}

FoxInfo myFoxInfo[] =
{
	{"EDGETENV", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDGETENV("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjU5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNTkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDGETLIN</XNAME>
			<DESCRIPTIO><![CDATA[ELIN  _EdGetLineNum(WHANDLE, EDPOS )

This example opens an edit session for a file specified by a parameter and gets the EDPOS for line 12 by calling _EdGetLinePos().  It then calls _EdGetLineNum() on this EDPOS, and if all is right with this section of the world, this should return 12.  Next it increments the EDPOS and each time calls _EdGetLineNum() until the EDLINE returned is changes.  At this point, it calls _EdGetLinePos() for line 13 to show that everything jibes.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(unsigned long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 6;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDPOS edpos;
	EDLINE edlin, original;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);

	edpos = _EdGetLinePos(wh, 12);
	_PutStr("\n_EdGetLinePos(wh, 12) =");
	putLong(edpos);

	original = edlin = _EdGetLineNum(wh, edpos);

	for (;;)
	{
		_PutStr("\n_EdGetLineNum(wh,");
		putLong(edpos);
		_PutStr(") = ");
		putLong(edlin);

		if (edlin != original)
		{
			break;
		}
        edpos++;
		edlin = _EdGetLineNum(wh, edpos);
	}

    edpos = _EdGetLinePos(wh, 13);
	_PutStr("\n_EdGetLinePos(wh, 13) ="); putLong(edpos);
}

FoxInfo myFoxInfo[] =
{
	{"EDGETLPOS", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDGETLPOS("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDY0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwNjQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDGETLPO</XNAME>
			<DESCRIPTIO><![CDATA[EDPOS  _EdGetLinePos(WHANDLE, ELINE )

This example opens an edit session for a file specified by a parameter and gets the EDPOS for line 12 by calling _EdGetLinePos().  It then calls _EdGetLineNum() on this EDPOS, and if all is right with this section of the world, this should return 12.  Next it increments the EDPOS and each time calls _EdGetLineNum() until the EDLINE returned is changes.  At this point, it calls _EdGetLinePos() for line 13 to show that everything jibes.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(unsigned long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 6;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDPOS edpos;
	EDLINE edlin, original;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);

	edpos = _EdGetLinePos(wh, 12);
	_PutStr("\n_EdGetLinePos(wh, 12) =");
	putLong(edpos);

	original = edlin = _EdGetLineNum(wh, edpos);

	for (;;)
	{
		_PutStr("\n_EdGetLineNum(wh,");
		putLong(edpos);
		_PutStr(") = ");
		putLong(edlin);

		if (edlin != original)
		{
			break;
		}
        edpos++;
		edlin = _EdGetLineNum(wh, edpos);
	}

    edpos = _EdGetLinePos(wh, 13);
	_PutStr("\n_EdGetLinePos(wh, 13) ="); putLong(edpos);
}

FoxInfo myFoxInfo[] =
{
	{"EDGETLPOS", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDGETLPOS("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTQzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNDMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDGETPOS</XNAME>
			<DESCRIPTIO><![CDATA[EDPOS  _EdGetPos(WHANDLE)

This example opens an edit session for a file specified by a parameter.  After setting the current insertion point with _EdSetPos(), a call to _EdGetPos() is made to verify that it returns the insertion point.  After selecting text with _EdSelect(), a call to _EdGetPos() is made to verify that it returns the anchor point.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 6;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDPOS edpos;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdSetPos(wh, 19);
	_PutStr("\n_EdSetPos(wh, 19)");
	edpos = _EdGetPos(wh);
	_PutStr("\n_EdGetPos(wh) ="); putLong(edpos);

	_EdSelect(wh, 5, 12);
	_PutStr("\n_EdSelect(wh, 5, 12)");
	edpos = _EdGetPos(wh);
	_PutStr("\n_EdGetPos(wh) ="); putLong(edpos);
}

FoxInfo myFoxInfo[] =
{
	{"EDGETPOS", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDGETPOS("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjY1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDGETSTR</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdGetStr(WHANDLE, EDPOS, EDPOS, TEXT *)

This example is an API routine takes a file name as a parameter and returns the file's first 16 bytes.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;
    char FAR *buffer;
    char FAR *pFileName;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1)) {
		_Error(182); // "Insufficient memory"
	}
    _HLock(parm->p[0].val.ev_handle);
	pFileName = _HandToPtr(parm->p[0].val.ev_handle);
	pFileName[parm->p[0].val.ev_length] = '\0';
	wh = _EdOpenFile(pFileName, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);
	if ((buffer = _Alloca(17)) == 0) {
		_Error(182); // "Insufficient memory"
	}
	_EdGetStr(wh, 1, 16, buffer);
	buffer[16] = '\0';
	_RetChar(buffer);
}
FoxInfo myFoxInfo[] = {
	{"EDGETSTR", (FPFI) Example, 1, "C"},
};
FoxTable _FoxTable = {
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? EDGETSTR("x") && returns the first 16 characters of file "x"
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMzAyLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAzMDIuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDINDENT</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdIndent(WHANDLE, int)

This example opens an edit session for a file specified by a parameter and indents lines 12 and 13 by a single tab stop.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdSelect(wh, _EdGetLinePos(wh, 12), _EdGetLinePos(wh, 14));
	_EdIndent(wh, 1);
}

FoxInfo myFoxInfo[] =
{
	{"EDINDENT", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDINDENT("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjQwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNDAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDINSERT</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdInsert(WHANDLE, TEXT *, BYTES)

This example opens an edit session for a file specified by a parameter and inserts the line of text "Hello, world" as the new thirteenth line.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdSetPos(wh, _EdGetLinePos(wh, 13));
	_EdInsert(wh, "Hello, world\r\n", _StrLen("Hello, world\r\n"));
}

FoxInfo myFoxInfo[] =
{
	{"EDINSERT", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDINSERT("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTg5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDLASTER</XNAME>
			<DESCRIPTIO><![CDATA[int  _EdLastError(WHANDLE)

This example displays the error code returned by _EdLastError() after a number of editor operations.  The name of a file to work on is the parameter to the API function.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;
	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
	char FAR *pFileName;
	WHANDLE wh;
	EDENV EdEnv;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
    _HLock(parm->p[0].val.ev_handle);
	pFileName = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	pFileName[parm->p[0].val.ev_length] = '\0';

	wh = _EdOpenFile(pFileName, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);
//
//	Position past end of file
//
	_EdGetEnv(wh, &EdEnv);
	_EdSetPos(wh, EdEnv.length + 128);
	_PutStr("\n_EdLastError() ="); putLong(_EdLastError(wh));
//
//	_EdCopy() with no selection
//
	_EdSetPos(wh, 1);
	_EdCopy(wh);
	_PutStr("\n_EdLastError() ="); putLong(_EdLastError(wh));
//
//	_EdScrollToSel() with no selection
//
	_EdScrollToSel(wh, TRUE);
	_PutStr("\n_EdLastError() ="); putLong(_EdLastError(wh));
}

FoxInfo myFoxInfo[] =
{
	{"EDLASTERR", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDLASTERR("x")  && displays _EdLastError() after operations on file "x"
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTQ5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNDkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDOPEN</XNAME>
			<DESCRIPTIO><![CDATA[WHANDLE  _EdOpenFile(TEXT *filename)

This examples opens an editor session for a file specified by a parameter.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"EDOPEN", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDOPEN("x")  && opens editor session for file "x"
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjM3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMzcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDPASTE</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdPaste(WHANDLE)

This example opens a file specified by a parameter for editing, copies the first character to the clipboard using _EdCopy(), and pastes it after the second character using _EdPaste().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

    _EdSelect(wh, 0, 1);
	_EdCopy(wh);
	_EdSetPos(wh, 2);
	_EdPaste(wh);
}

FoxInfo myFoxInfo[] =
{
	{"EDCOPY", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDCOPY("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjk3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyOTcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDPOSINV</XNAME>
			<DESCRIPTIO><![CDATA[BOOL  _EdPosInView(WHANDLE, EDPOS)

This example opens a file specified by a parameter for editing.  After scrolling to the top of the file, _EdPosInView() is called to check whether the top of file and bottom of file are in view and the results are printed to the screen.   Then it scrolls to the bottom of the file, and again _EdPosInView() is called to check whether the top of file and bottom of file are in view.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDENV EdEnv;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdGetEnv(wh, &EdEnv);

	_EdScrollToPos(wh, 0, FALSE);
	_PutStr("\n_EdScrollToPos(wh, 0)");
	_PutStr("\n_EdPosInView(wh, 0) =");
	putLong(_EdPosInView(wh, 0));
	_PutStr("\n_EdPosInView(wh, EdEnv.length) =");
	putLong(_EdPosInView(wh, EdEnv.length));

	_EdScrollToPos(wh, EdEnv.length, FALSE);
	_PutStr("\n_EdScrollToPos(wh, EdEnv.length)");
	_PutStr("\n_EdPosInView(wh, 0) =");
	putLong(_EdPosInView(wh, 0));
	_PutStr("\n_EdPosInView(wh, EdEnv.length) =");
	putLong(_EdPosInView(wh, EdEnv.length));
}

FoxInfo myFoxInfo[] =
{
	{"POSINVIEW", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= POSINVIEW("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjE2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMTYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDREDO</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdRedo(WHANDLE)

This example opens a file specified by a parameter for editing.  After inserting a new line, the insertion is backed out using _EdUndo() and then _EdRedo() is called restore the inserted line.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdSetPos(wh, _EdGetLinePos(wh, 13));
	_EdInsert(wh, "Hello, world\r\n", _StrLen("Hello, world\r\n"));

	_Execute("WAIT 'New line inserted.  Press any key to undo.'");
	_EdUndo(wh);

	_Execute("WAIT 'Insertion undone.  Press any key to redo.'");
	_EdRedo(wh);
}

FoxInfo myFoxInfo[] =
{
	{"EDREDO", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDREDO("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDkzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwOTMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDREVERT</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdRevert(WHANDLE)

This example opens a file specified by a parameter for editing.  After some editing, insertion of a new line, indenting of two lines, and deletion of two lines, the changes are backed out by a call to _EdRevert().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdSetPos(wh, _EdGetLinePos(wh, 13));
	_EdInsert(wh, "Hello, world\r\n", _StrLen("Hello, world\r\n"));

	_EdSelect(wh, _EdGetLinePos(wh, 14), _EdGetLinePos(wh, 16));
	_EdIndent(wh, 1);

	_EdSelect(wh, _EdGetLinePos(wh, 9), _EdGetLinePos(wh, 12));
	_EdDelete(wh);

	_EdRevert(wh);
}

FoxInfo myFoxInfo[] =
{
	{"EDREVERT", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDREVERT("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjMzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMzMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDSAVE</XNAME>
			<DESCRIPTIO><![CDATA[void _EdSave(WHANDLE)

This example opens a file specified by a parameter for editing.  Some editing is performed, insertion of a new line, indenting of two lines, and deletion of two lines.  After the insertion of the new line but before the indentation and deletion,  _EdSave() is called.  Three calls to _EdUndo() are made in an attempt to undo all of the editing, but the insertion made before the call to _EdSave() cannot be undone.  Two more edit operations are performed with a call to _EdSave() between them.  _EdRevert() is called, but it too can only back out changes made since the last _EdSave().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdSetPos(wh, _EdGetLinePos(wh, 13));
	_EdInsert(wh, "Hello, world\r\n", _StrLen("Hello, world\r\n"));

	_EdSave(wh);

    _EdSelect(wh, _EdGetLinePos(wh, 14), _EdGetLinePos(wh, 16));
	_EdIndent(wh, 1);

    _EdSelect(wh, _EdGetLinePos(wh, 9), _EdGetLinePos(wh, 12));
	_EdDelete(wh);

	_Execute("WAIT 'Press any key to undo changes.'");
	_EdUndo(wh);  // undo deletion
	_EdUndo(wh);  // undo indent
	_EdUndo(wh);  // attempt to undo insertion, but can't

    _EdSelect(wh, _EdGetLinePos(wh, 14), _EdGetLinePos(wh, 16));
	_EdIndent(wh, 1);

	_EdSave(wh);

    _EdSelect(wh, _EdGetLinePos(wh, 9), _EdGetLinePos(wh, 12));
	_EdDelete(wh);

	_EdRevert(wh);	// undoes deletion
}

FoxInfo myFoxInfo[] =
{
	{"EDSAVE", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDSAVE("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTg3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDSCTOPO</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdScrollToPos(WHANDLE, EDPOS , BOOL)

This example opens a file specified by a parameter for editing.  After scrolling to the top of the file by calling _EdScrollToPos(), _EdPosInView() is called to check whether the top of file and bottom of file are in view and the results are printed to the screen.   Then it scrolls to the bottom of the file by calling _EdScrollToPos(), and again _EdPosInView() is called to check whether the top of file and bottom of file are in view.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDENV EdEnv;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdGetEnv(wh, &EdEnv);

	_EdScrollToPos(wh, 0, FALSE);
	_PutStr("\n_EdScrollToPos(wh, 0)");
	_PutStr("\n_EdPosInView(wh, 0) =");
	putLong(_EdPosInView(wh, 0));
	_PutStr("\n_EdPosInView(wh, EdEnv.length) =");
	putLong(_EdPosInView(wh, EdEnv.length));

	_EdScrollToPos(wh, EdEnv.length, FALSE);
	_PutStr("\n_EdScrollToPos(wh, EdEnv.length)");
	_PutStr("\n_EdPosInView(wh, 0) =");
	putLong(_EdPosInView(wh, 0));
	_PutStr("\n_EdPosInView(wh, EdEnv.length) =");
	putLong(_EdPosInView(wh, EdEnv.length));
}

FoxInfo myFoxInfo[] =
{
	{"POSINVIEW", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= POSINVIEW("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTUxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNTEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDSCTOSE</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdScrollToSel(WHANDLE, BOOL)

This example opens a file specified by a parameter for editing.  A selection is made near the bottom of the file.  After a key press in response to a WAIT, the edit window is scrolled to the selection by calling _EdScrollToSel().  The same selection, scroll to selection operation is done with a selection near the top of the file.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDENV EdEnv;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READONLY);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdScrollToPos(wh, 0, TRUE);

	_EdGetEnv(wh, &EdEnv);
	_EdSelect(wh, EdEnv.length - 16, EdEnv.length);

	_PutStr("\nMade selection at end of file.");
	_Execute("WAIT 'Press any key to scroll to selection.'");

	_EdScrollToSel(wh, TRUE);

	_EdSelect(wh, 1, 16);

	_PutStr("\nMade selection at end of file.");
	_Execute("WAIT 'Press any key to scroll to selection.'");

	_EdScrollToSel(wh, TRUE);
}

FoxInfo myFoxInfo[] =
{
	{"TOSEL", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= TOSEL("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTkwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxOTAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDSELECT</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdSelect(WHANDLE, EDPOS, EDPOS)

This example opens a file specified by a parameter for editing, selects the first character using _EdSelect(), copies the selection to the clipboard using _EdCopy(), and pastes it after the second character using _EdPaste().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

    _EdSelect(wh, 0, 1);
	_EdCopy(wh);
	_EdSetPos(wh, 2);
	_EdPaste(wh);
}

FoxInfo myFoxInfo[] =
{
	{"EDCOPY", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDCOPY("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTg1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDSENDKE</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdSendKey(WHANDLE, int)

This example opens a file specified by a parameter for editing.  A line of text, "Hello, World",  is inserted by sending the individual characters with _EdSendKey().  An ASCII escape character is inserted using _EdSendKey().  Notice that it is not interpreted as "discard edit session."]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);
//
//	Insert a line of text using _EdSendKey()
//
	_EdSetPos(wh, 0);
	_EdSendKey(wh, 'H');
	_EdSendKey(wh, 'e');
	_EdSendKey(wh, 'l');
	_EdSendKey(wh, 'l');
	_EdSendKey(wh, 'o');
	_EdSendKey(wh, ',');
	_EdSendKey(wh, ' ');
	_EdSendKey(wh, 'W');
	_EdSendKey(wh, 'o');
	_EdSendKey(wh, 'r');
	_EdSendKey(wh, 'l');
	_EdSendKey(wh, 'd');
	_EdSendKey(wh, '.');
	_EdSendKey(wh, 0x0d); // carriage return
	_EdSendKey(wh, 0x0a); // line feed

	_EdSendKey(wh, 0x1b); // esc char code is inserted in file
}

FoxInfo myFoxInfo[] =
{
	{"SENDKEY", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= SENDKEY("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDSETENV</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdSetEnv(WHANDLE, *EDENV)

This example opens a file specified by a parameter for editing.  After indent the first two lines of the file,  _EdSetEnv() is used to change the size of a tab stop to 6 characters and then to 9 characters.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDENV EdEnv;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdGetEnv(wh, &EdEnv);

	_EdSelect(wh, _EdGetLinePos(wh, 1), _EdGetLinePos(wh, 3));
	_EdIndent(wh, 1);

    _Execute("WAIT 'Press any key to change tabs to 6 characters.'");
	EdEnv.tabWidth = 6;
	_EdSetEnv(wh, &EdEnv);

	_Execute("WAIT 'Press any key to change tabs to 9 characters.'");
	EdEnv.tabWidth = 9;
	_EdSetEnv(wh, &EdEnv);
}

FoxInfo myFoxInfo[] =
{
	{"EDSETENV", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDSETENV("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDSETPOS</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdSetPos(WHANDLE, EDPOS)

This example opens a file specified by a parameter for editing.  Using _EdSetPos() the insertion point is set to position 19 of the file.  _EdGetPos() is called and some text is inserted to verify that the insertion point has been set.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 6;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDPOS edpos;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdSetPos(wh, 19);
	_PutStr("\n_EdSetPos(wh, 19)");
	edpos = _EdGetPos(wh);
	_PutStr("\n_EdGetPos(wh) ="); putLong(edpos);
	_EdInsert(wh, "*** Inserted at EDPOS = 19 ***",
		_StrLen("*** Inserted at EDPOS = 19 ***"));
}

FoxInfo myFoxInfo[] =
{
	{"EDSETPOS", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};








]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDSETPOS('x')
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDSKIPLI</XNAME>
			<DESCRIPTIO><![CDATA[EDPOS  _EdSkipLines(WHANDLE, EDPOS, int )

This example opens a file specified by a parameter for editing.  It uses _EdSkipLines() to find the EDPOSes to select lines 3 and 4, two lines from the top and then two more lines.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;
	EDPOS edpos;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_Execute("WAIT 'Using _EdSkipLines() to select lines 3 and 4'");

    edpos = _EdSkipLines(wh, 0, 2); // skip to two lines from top
	_EdSelect(wh, edpos, _EdSkipLines(wh, edpos, 2));
		// select next two lines
}

FoxInfo myFoxInfo[] =
{
	{"SKIPLINE", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= SKIPLINE("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDUNDO</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdUndo(WHANDLE)

This example opens a file specified by a parameter for editing.  After inserting a new line, the insertion is backed out using _EdUndo() and then _EdRedo() is called restore the inserted line.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define pFILENAME ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	pFILENAME[parm->p[0].val.ev_length] = '\0';

    _HLock(parm->p[0].val.ev_handle);
	wh = _EdOpenFile(pFILENAME, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdSetPos(wh, _EdGetLinePos(wh, 13));
	_EdInsert(wh, "Hello, world\r\n", _StrLen("Hello, world\r\n"));

	_Execute("WAIT 'New line inserted.  Press any key to undo.'");
	_EdUndo(wh);

	_Execute("WAIT 'Insertion undone.  Press any key to redo.'");
	_EdRedo(wh);
}

FoxInfo myFoxInfo[] =
{
	{"EDREDO", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDREDO("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EDUNDOON</XNAME>
			<DESCRIPTIO><![CDATA[void  _EdUndoOn(WHANDLE, BOOL)

This example shows how _EdUndoOn() is used to group edit operations that can be undone as a group.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>
#define TRUE	1
#define FALSE	0

void FAR Example(ParamBlk FAR *parm)
{
	char FAR *pFileName;
	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1)) {
		_Error(182); // "Insufficient memory"
	}
    _HLock(parm->p[0].val.ev_handle);
	pFileName = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	pFileName[parm->p[0].val.ev_length] = '\0';
	wh = _EdOpenFile(pFileName, FO_READWRITE);
	_HUnLock(parm->p[0].val.ev_handle);

	_EdUndoOn(wh, TRUE); // start undo group

    _EdSetPos(wh, _EdGetLinePos(wh, 13));
	_EdInsert(wh, "Hello, world\r\n", _StrLen("Hello, world\r\n"));
    _EdSelect(wh, _EdGetLinePos(wh, 14), _EdGetLinePos(wh, 16));
	_EdIndent(wh, 1);

	_EdUndoOn(wh, FALSE); // end undo group
	_EdUndoOn(wh, TRUE); // start another undo group

    _EdSelect(wh, _EdGetLinePos(wh, 9), _EdGetLinePos(wh, 12));
	_EdDelete(wh);
    _EdSetPos(wh, _EdGetLinePos(wh, 13));
	_EdInsert(wh, "Hello, world\r\n", _StrLen("Hello, world\r\n"));

	_Execute("WAIT 'Press any key to undo changes.'");
	_EdUndoOn(wh, TRUE); // undoes to start of undo group
}
FoxInfo myFoxInfo[] = {
	{"EDUNDOON", (FPFI) Example, 1, "C"},
};
FoxTable _FoxTable = {
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EDUNDOON("x")  && edit file "x"
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>ERROR</XNAME>
			<DESCRIPTIO><![CDATA[void  _Error(int code)

This example calls _Error() when _DBSkip() returns an error code.  The FoxPro code shows how to cause _Error() to be called.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *pblk)
{
	int RetCode;

    if ((RetCode = _DBSkip(-1, pblk->p[0].val.ev_long)) < 0) {
		_PutStr("\nError encountered in example program.");
        _Error(-RetCode);  // _DBSkip() returns negative error code
	}
	_RetInt(RetCode, 10);
}
FoxInfo myFoxInfo[] = {
	{"DBSKIP", (FPFI) Example, 1, "I"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DO CreateTest

ON ERROR DO expectError
USE
= DBSKIP(1) 	&& _Error() called: no DBF in use
USE test
GO TOP
= DBSKIP(-1)
= DBSKIP(-1)	&& _Error() called: at top of file
GO BOTT
= DBSKIP(1)
= DBSKIP(1) 	&& _Error() called: at bottom of file
ON ERROR

PROCEDURE expectError
? "ERROR: " + MESSAGE()
RETURN


PROCEDURE CreateTest

CREATE TABLE test (ABC C(20))
APPEND BLANK
REPLACE ABC WITH "Golly month of"
APPEND BLANK
REPLACE ABC WITH "A twelveth of"
APPEND BLANK
REPLACE ABC WITH "Hello, world"
APPEND BLANK
REPLACE ABC WITH "When in the"
GO TOP

RETURN]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>ERRORINF</XNAME>
			<DESCRIPTIO><![CDATA[int  _ErrorInfo(int code, char FAR *message)

This example displays the information returned by _ErrorInfo().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR ErrorInfo(ParamBlk FAR *parm)
{
	int ext;
	char FAR *message;


	if ((message =_Alloca(128)) == 0)
	{
		_Error(182); // "Insufficient memory"
	}
	ext = _ErrorInfo((int) parm->p[0].val.ev_long, message);

	_PutChr('\n'); putLong(ext); _PutStr(" "); _PutStr(message);
}

FoxInfo myFoxInfo[] =
{
	{"ERRORINFO", (FPFI) ErrorInfo, 1, "I"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= ERRORINFO(0)
= ERRORINFO(1)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EVALUATE</XNAME>
			<DESCRIPTIO><![CDATA[int  _Evaluate(Value FAR *res, char FAR *expr)

This example replicates the functionality of FoxPro's EVAL() function.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR EvaluateEx(ParamBlk FAR *parm)
{
	char FAR *expr;
	Value result;
//
//	Null terminate character string
//
	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);
	expr = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	expr[parm->p[0].val.ev_length] = '\0';

	_Evaluate(&result, expr);
	_RetVal(&result);

    _HUnLock(parm->p[0].val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"XEVAL", (FPFI) EvaluateEx, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};


]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? XEVAL("2 + 3")
? XEVAL("'a' + 'b'")
? XEVAL("SIN(PI()/2))")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>EXECUTE</XNAME>
			<DESCRIPTIO><![CDATA[int  _Execute(char FAR *stmt)

This example uses _Execute() to execute the FoxPro command string passed as an argument to the API function.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR ExecuteEx(ParamBlk FAR *parm)
{
	char FAR *cmd;
//
//	Null terminate character string
//
	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);
	cmd = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	cmd[parm->p[0].val.ev_length] = '\0';

	_Execute(cmd);

    _HUnLock(parm->p[0].val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"EXEC", (FPFI) ExecuteEx, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};


]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EXEC("? 'Hello, world.'")
= EXEC("DISPLAY STATUS")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FCHSIZE</XNAME>
			<DESCRIPTIO><![CDATA[int  _FCHSize(FCHAN chan, long length)

This example creates a file TEMP.TXT and sets its size to 8192 using _FCHSize().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
    FCHAN fchan = _FCreate("temp.txt", FC_NORMAL);
	_FCHSize(fchan, 8196);
	_FClose(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"FCHSIZE", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FCLOSE</XNAME>
			<DESCRIPTIO><![CDATA[int  _FClose(FCHAN chan)

This example creates a file TEMP.TXT, sets its size to 8192, and closes it using _FClose().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
    FCHAN fchan = _FCreate("temp.txt", FC_NORMAL);
	_FCHSize(fchan, 8196);
	_FClose(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"FCHSIZE", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FCOPY</XNAME>
			<DESCRIPTIO><![CDATA[int  _FCopy(FCHAN dc, long dpos, FCHAN sc, long spos, long len)

This example creates two files.  It writes the text "Hello, world" to one of these files and then copies the contents of this file, beginning with the third byte, to the other file.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	FCHAN fchan1, fchan2;
	int len;

	fchan1 = _FCreate("temp1.txt", FC_NORMAL);
	_FPuts(fchan1, "Hello, world.");
	_FFlush(fchan1);

	len = _FSeek(fchan1, 0, FS_FROMEOF); // determine length of file

    fchan2 = _FCreate("temp2.txt", FC_NORMAL);
	_FCopy(fchan2, 0, fchan1, 2, len - 2);

	_FClose(fchan1);
	_FClose(fchan2);
}

FoxInfo myFoxInfo[] =
{
	{"FCOPY", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};


]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FCREATE</XNAME>
			<DESCRIPTIO><![CDATA[FCHAN  _FCreate(char FAR *filename, int mode)

This example uses _FCreate() to create a number of files using the various mode flags of _FCreate().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	FCHAN fchan;

	fchan = _FCreate("normal.tmp", FC_NORMAL);
	_FClose(fchan);

	fchan = _FCreate("readonly.tmp", FC_READONLY);
	_FClose(fchan);

	fchan = _FCreate("hidden.tmp", FC_HIDDEN);
	_FClose(fchan);

	fchan = _FCreate("system.tmp", FC_SYSTEM);
	_FClose(fchan);

	fchan = _FCreate("temp.tmp", FC_TEMPORARY);
	_FClose(fchan);

	fchan = _FCreate("multi.tmp", FC_SYSTEM | FC_READONLY);
	_FClose(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"FCREATE", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FEOF</XNAME>
			<DESCRIPTIO><![CDATA[int  _FEOF(FCHAN chan)

This example creates a file and sets its length to 8192.  Then it seeks to the beginning of the file and calls _FEOF(), which should return 0 (FALSE).  Next it seeks to the end of the file and again calls _FEOF(), which should this time return 1 (TRUE).]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    FCHAN fchan = _FCreate("temp.txt", FC_NORMAL);
	_FCHSize(fchan, 8196);
	_FFlush(fchan);

	_FSeek(fchan, 0, FS_FROMBOF);
	_PutStr("\n_FSeek(fchan, 0, FS_FROMBOF)");
	_PutStr("\n_FEOF(fchan) ="); putLong(_FEOF(fchan));

	_FSeek(fchan, 0, FS_FROMEOF);
	_PutStr("\n_FSeek(fchan, 0, FS_FROMEOF)");
	_PutStr("\n_FEOF(fchan) ="); putLong(_FEOF(fchan));
}

FoxInfo myFoxInfo[] =
{
	{"FEOF", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};


]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FERROR</XNAME>
			<DESCRIPTIO><![CDATA[int  _FError(void)

This example attempts to _FOpen() a file called "nofile.abc" which presumably does not exists.  It then calls _FError(), which should return 2 for "file not found."]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
	FCHAN fchan = _FOpen("nofile.abc", FC_READONLY);
	_PutStr("\nAttempted to _FOpen() a file which does not exist.");
	_PutStr("\n_FError() ="); putLong(_FError());
}

FoxInfo myFoxInfo[] =
{
	{"FERROR", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FFLUSH</XNAME>
			<DESCRIPTIO><![CDATA[int  _FFlush(FCHAN chan)

This example on loading the library creates a file and sets its length to 8192.  Doing a DIR temp.txt at the Command shows that the size of the file on disk is still 0.  However, after doing the = XFFLUSH(), issuing a DIR temp.tmp shows that the file on disk reflects the _FCHSize() call and shows a file size of 8192.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

static FCHAN fchan;

void FAR CreateIt(ParamBlk FAR *parm)
{
	fchan = _FCreate("temp.txt", FC_NORMAL);
	_FCHSize(fchan, 8196);
}

void FAR FFlushEx(ParamBlk FAR *parm)
{
	_FFlush(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) CreateIt, CALLONLOAD, ""},
	{"XFFLUSH", (FPFI) FFlushEx, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
DIR temp.tmp  && size on disk is still 0
= XFFLUSH()
DIR temp.tmp  && size on disk is 8192
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FGETS</XNAME>
			<DESCRIPTIO><![CDATA[int  _FGets(FCHAN chan, char FAR *buffer, int maxlen)

This example opens a file specified by a parameter and reads each line from the file with _FGets() and displays it.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

#define BUFFSIZE 256
static char lineBuffer[BUFFSIZE];

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
	FCHAN fchan;
//
//	Null terminate file name
//
	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);

	((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))
		[parm->p[0].val.ev_length] = '\0';

	if ((fchan = _FOpen((char FAR *) _HandToPtr(parm->p[0].val.ev_handle),
		FC_NORMAL)) < 0)
	{
		_UserError("Could not open file.");
	}
	_HUnLock(parm->p[0].val.ev_handle);

    while (!_FEOF(fchan))
	{
        _FGets(fchan, lineBuffer, BUFFSIZE);
		_PutStr(lineBuffer); _PutChr('\n');
	}
    _FClose(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"XFGETS", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
fc = FCREATE("x", 0)
= FPUTS(fc, REPL("X", 512), 512)
= FCLOSE(fc)
= XFGETS("x")
DELETE FILE x]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FINDMEMO</XNAME>
			<DESCRIPTIO><![CDATA[long  _FindMemo(Locator FAR *fld)

This example retrieves the contents of a memo field.  _FindMemo() is used to find the location of the memo contents within the memo file.  We _FSeek() to this location and _FRead() _MemoSize() bytes from the memofile.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR FindMemoEx(ParamBlk FAR *parm)
{

	Locator FAR *memoFldLoc;
	FCHAN fchMemo;
	char FAR *memoContents;
	int memoLen;
	long loc;

	if ((fchMemo = _MemoChan(-1)) == -1)
	{
		_UserError("_MemoChan() failed");
	}
    memoFldLoc = &parm->p[0].loc;

	if ((loc = _FindMemo(memoFldLoc)) < 0)
	{
		_UserError("_FindMemo() failed");
	}
	if ((memoLen = _MemoSize(memoFldLoc)) < 0)
	{
		_UserError("_MemoSize() failed");
	}
	if ((memoContents = _Alloca(memoLen + 1)) == 0)
	{
		_Error(182); // "Insufficient memory"
	}
    _FSeek(fchMemo, loc, FS_FROMBOF);
	_FRead(fchMemo, memoContents, memoLen);
	memoContents[memoLen] = '\0';
	_RetChar(memoContents);
}

FoxInfo myFoxInfo[] =
{
	{"GETMEMO", (FPFI) FindMemoEx, 1, "R"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
CREATE TABLE WMemo (MemoField M)
APPEND BLANK
REPLACE MemoField WITH "Hello, World."
? GETMEMO(@MemoField)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FINDVAR</XNAME>
			<DESCRIPTIO><![CDATA[int  _FindVar(NTI nti, int where, Locator FAR *loc)

This example does things "takes the long way home" in displaying the value of a FoxPro variable.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}


void FAR NameTableIndexEx(ParamBlk FAR *parm)
{
	NTI nti;
	char FAR *name;
	Locator loc;
	Value val;
//
//	Null terminate character string, name of variable
//
	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);
	name = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	name[parm->p[0].val.ev_length] = '\0';

	nti = _NameTableIndex(name);

	_FindVar(nti, 0, &loc);
	_Load(&loc, &val);
	_PutValue(&val);
}

FoxInfo myFoxInfo[] =
{
	{"QMARK", (FPFI) NameTableIndexEx, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FINDWIND</XNAME>
			<DESCRIPTIO><![CDATA[int  _FindWindow(WHANDLE FAR *wh, Point pt)

This example waits for a left mouse button click and then using _FindWindow() gets the window handle for the mouse down position.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR MyFindWindowEx(ParamBlk FAR *parm)
{
    WHANDLE wh;
	Point mousePos;
	int where;
//
//  Get mouse position when left button goes down
//
	while (_InKey(0, MOUSEACTIVE | HIDECURSOR) != 151);
	while (!_MousePos(&mousePos));

    switch (where = _FindWindow(&wh, mousePos))
    {
        case inBorder:
            _PutStr("\nMouse down inBorder"); break;
        case inHelp:
            _PutStr("\nMouse down inHelp"); break;
        case inContent:
            _PutStr("\nMouse down inContent"); break;
        case inDrag:
            _PutStr("\nMouse down inDrag"); break;
        case inGrow:
            _PutStr("\nMouse down inGrow"); break;
        case inGoAway:
            _PutStr("\nMouse down inGoAway"); break;
        case inZoom:
            _PutStr("\nMouse down inZoom"); break;
        case inVUpArrow:
            _PutStr("\nMouse down inVUpArrow"); break;
        case inVDownArrow:
            _PutStr("\nMouse down inVDownArrow"); break;
        case inVPageUp:
            _PutStr("\nMouse down inVPageUp"); break;
        case inVPageDown:
            _PutStr("\nMouse down inVPageDown"); break;
        case inVThumb:
            _PutStr("\nMouse down inVThumb"); break;
        case inHUpArrow:
            _PutStr("\nMouse down inHUpArrow"); break;
        case inHDownArrow:
            _PutStr("\nMouse down inHDownArrow"); break;
        case inHPageUp:
            _PutStr("\nMouse down inHPageUp"); break;
        case inHPageDown:
            _PutStr("\nMouse down inHPageDown"); break;
        case inHThumb:
            _PutStr("\nMouse down inHThumb"); break;
        case inMenuBar:
            _PutStr("\nMouse down inMenuBar"); break;
        default:
            _PutStr("\nMouse down someplace else"); break;
    }
	_GlobalToLocal(&mousePos, wh);
	_PutStr("\nPosition relative to window:");
	putLong(mousePos.v, 5);
	_PutChr(' ');
	putLong(mousePos.h, 5);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) MyFindWindowEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[? "Click mouse on a window"
SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FINDWINP</XNAME>
			<DESCRIPTIO><![CDATA[int  _FindWindowP(WHANDLE FAR *wh, Point pt)

This example waits for a left mouse button click and then using _FindWindowP() gets the window handle for the mouse down position.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR MyFindWindowEx(ParamBlk FAR *parm)
{
    WHANDLE wh;
	Point mousePos;
	int where;
//
//  Get mouse position when left button goes down
//
	while (_InKey(0, MOUSEACTIVE | HIDECURSOR) != 151);
	while (!_MousePosP(&mousePos));

	switch (where = _FindWindowP(&wh, mousePos))
    {
        case inBorder:
            _PutStr("\nMouse down inBorder"); break;
        case inHelp:
            _PutStr("\nMouse down inHelp"); break;
        case inContent:
            _PutStr("\nMouse down inContent"); break;
        case inDrag:
            _PutStr("\nMouse down inDrag"); break;
        case inGrow:
            _PutStr("\nMouse down inGrow"); break;
        case inGoAway:
            _PutStr("\nMouse down inGoAway"); break;
        case inZoom:
            _PutStr("\nMouse down inZoom"); break;
        case inVUpArrow:
            _PutStr("\nMouse down inVUpArrow"); break;
        case inVDownArrow:
            _PutStr("\nMouse down inVDownArrow"); break;
        case inVPageUp:
            _PutStr("\nMouse down inVPageUp"); break;
        case inVPageDown:
            _PutStr("\nMouse down inVPageDown"); break;
        case inVThumb:
            _PutStr("\nMouse down inVThumb"); break;
        case inHUpArrow:
            _PutStr("\nMouse down inHUpArrow"); break;
        case inHDownArrow:
            _PutStr("\nMouse down inHDownArrow"); break;
        case inHPageUp:
            _PutStr("\nMouse down inHPageUp"); break;
        case inHPageDown:
            _PutStr("\nMouse down inHPageDown"); break;
        case inHThumb:
            _PutStr("\nMouse down inHThumb"); break;
        case inMenuBar:
            _PutStr("\nMouse down inMenuBar"); break;
        default:
            _PutStr("\nMouse down someplace else"); break;
    }
	_GlobalToLocalP(&mousePos, wh);
	_PutStr("\nPosition relative to window:");
	putLong(mousePos.v, 5);
	_PutChr(' ');
	putLong(mousePos.h, 5);
}

FoxInfo myFoxInfo[] =
{
    {"ONLOAD", (FPFI)MyFindWindowEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FOPEN</XNAME>
			<DESCRIPTIO><![CDATA[FCHAN  _FOpen(char FAR *filename, int mode)

This example creates a test file.  It then opens it FO_READONLY and attempts to write to it.  As a result _FError() should return 5 for "Access denied."  Next, the example opens the test file FO_WRITEONLY and attempts to read from it.  Again, _FError() should return 5.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

#define BUFFSIZE 256
static char lineBuffer[BUFFSIZE];

void FAR Example(ParamBlk FAR *parm)
{
	FCHAN fchan;

	fchan = _FCreate("temp.tmp", FC_NORMAL);
	_FCHSize(fchan, 8192);
	_FClose(fchan);

	fchan = _FOpen("temp.tmp", FO_READONLY);
	_FPuts(fchan, "Hello, world");
	_PutStr("\nAttempt to _FPuts() to file _FOpen()d FO_READONLY");
	_PutStr("\n_FError() ="); putLong(_FError());
    _FClose(fchan);

	fchan = _FOpen("temp.tmp", FO_WRITEONLY);
	_FGets(fchan, lineBuffer, BUFFSIZE);
	_PutStr("\nAttempt to _FGets() from file _FOpen()d FO_WRITEONLY");
	_PutStr("\n_FError() ="); putLong(_FError());
    _FClose(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"FOPEN", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FPUTS</XNAME>
			<DESCRIPTIO><![CDATA[int  _FPuts(FCHAN chan, char FAR *buffer)

This example creates a file and writes the text "Hello, world" to the file using _FPuts().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	FCHAN fchan;

	fchan = _FCreate("temp.tmp", FC_NORMAL);
	_FPuts(fchan, "Hello, world.");
	_FClose(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"FPUTS", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};


]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FREAD</XNAME>
			<DESCRIPTIO><![CDATA[int  _FRead(FCHAN chan, char FAR *buffer, int length)

This example creates a test file and gives it some contents.  It then attempts to read 32 bytes from the file using _FRead().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

#define BUFFSIZE 32
static char buffer[BUFFSIZE];

void FAR Example(ParamBlk FAR *parm)
{
	FCHAN fchan;
	int bytesRead;

	fchan = _FCreate("temp.tmp", FC_NORMAL);
	_FPuts(fchan, "Hello, world.");
	_FPuts(fchan, "Hello, world.");
	_FPuts(fchan, "Hello, world.");
	_FPuts(fchan, "Hello, world.");
	_FPuts(fchan, "Hello, world.");

	_FSeek(fchan, 0, FS_FROMBOF);

	bytesRead = _FRead(fchan, buffer, BUFFSIZE - 1);
	buffer[bytesRead] = '\0';
	_PutStr(buffer);

    _FClose(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"FREAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FREEHAND</XNAME>
			<DESCRIPTIO><![CDATA[void  _FreeHand(MHANDLE hand)

This example allocates 1024 blocks of 16384 byte memory blocks (for a total of 16 Meg), freeing the previous memory block using _FreeHand() before allocating the next.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	MHANDLE mh;
	int i;

	for (i = 0; i < 1024; i++)
	{
		if ((mh = _AllocHand(16384)) == 0)
		{
			_Error(182);  // "Insufficient memory"
		}
		_FreeHand(mh);
	}
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FSEEK</XNAME>
			<DESCRIPTIO><![CDATA[long  _FSeek(FCHAN chan, long position, int mode)

This example consists of one API routine which takes two parameters, a file name and an integer.  It opens the file.  Calling _FSeek() using the the FS_FROMBOF flag, it seeks the position specified by the integer parameter, and reads a single byte from the file at that position.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	FCHAN fchan;
	char x;
//
//	Null terminate file name
//
	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);

	((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))
		[parm->p[0].val.ev_length] = '\0';

	if ((fchan = _FOpen((char FAR *) _HandToPtr(parm->p[0].val.ev_handle),
		FC_NORMAL)) < 0)
	{
		_UserError("Could not open file.");
	}
	_HUnLock(parm->p[0].val.ev_handle);

	_FSeek(fchan, parm->p[1].val.ev_long, FS_FROMBOF);
	_FRead(fchan, &x, 1);
	_RetInt(x, 10);
    _FClose(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"XFSEEK", (FPFI) Example, 2, "C,I"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
fc = FCREATE("x", 0)
= FPUTS(fc, "abcdefghijklmnopqrstuvwxyz", 26)
= FCLOSE(fc)

? XFSEEK("x", 2)  && displays 2nd byte of file x as an integer
? XFSEEK("x", 4)  && displays 2nd byte of file x as an integer

DELETE FILE x
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>FWRITE</XNAME>
			<DESCRIPTIO><![CDATA[int  _FWrite(FCHAN chan, char FAR *buffer, int length)

This example creates a test file and writes some data to it using _FWrite().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	FCHAN fchan;

	fchan = _FCreate("temp.tmp", FC_NORMAL);
	_FWrite(fchan, "Hello, world.", _StrLen("Hello, world."));
	_FWrite(fchan, "\xd\xa", 2);
	_FWrite(fchan, "1234567890", 10);
	_FClose(fchan);
}

FoxInfo myFoxInfo[] =
{
	{"FWRITE", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GETHANDS</XNAME>
			<DESCRIPTIO><![CDATA[unsigned  int  _GetHandSize(MHANDLE hand)

This example allocates memory blocks of various size from 1 to 2**15 and prints out the value returned by _GetHandSize() for these allocations.  Notice that the value returned by _GetHandSize() is only sometimes exactly equal to the requested size; usually it is a bit more.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 5;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
	MHANDLE mh;
	unsigned int allocSize;

	for (allocSize = 1;; allocSize *= 2)
	{
		if ((mh = _AllocHand(allocSize)) == 0)
		{
			_Error(182);  // "Insufficient memory"
		}
		_PutStr("\n_AllocHand("); putLong(allocSize); _PutStr(")");
		_PutStr("\n_GetHandSize() ="); putLong(_GetHandSize(mh));
		_FreeHand(mh);

		if (allocSize == 32768)
		{
			break;
		}
    }
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GETICMDK</XNAME>
			<DESCRIPTIO><![CDATA[int  _GetItemCmdKey(MENUID menuid, ITEMID itemid, char FAR *text)

This example creates a menu with three items, setting up a keyboard short cut for each item.  It uses  _GetItemCmdKey() to display the short cut keys.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}


void FAR GetItemCmdKeyEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;
	char FAR *shortcutString;
	int intKeyCode;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");
	_SetItemCmdKey(menuId, itemId, altKey | 0x78, "Alt+1");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");
	_SetItemCmdKey(menuId, itemId, altKey | 0x79, "Alt+2");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");
	_SetItemCmdKey(menuId, itemId, altKey | 0x7a, "Alt+3");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

    _ActivateMenu(menuId);

	if ((shortcutString = _Alloca(64)) == 0)
	{
		_DisposeMenu(menuId);
		_Error(182); // "Insufficient memory"
	}
    intKeyCode = _GetItemCmdKey(menuId, _GetItemId(menuId, 0), shortcutString);
	_PutStr("\nShortcut string = "); _PutStr(shortcutString);
	_PutStr("\nInternal key code ="); putLong(intKeyCode);

	intKeyCode = _GetItemCmdKey(menuId, _GetItemId(menuId, 1), shortcutString);
	_PutStr("\nShortcut string = "); _PutStr(shortcutString);
	_PutStr("\nInternal key code ="); putLong(intKeyCode);

	intKeyCode = _GetItemCmdKey(menuId, _GetItemId(menuId, 2), shortcutString);
	_PutStr("\nShortcut string = "); _PutStr(shortcutString);
	_PutStr("\nInternal key code ="); putLong(intKeyCode);

	_Execute("WAIT");
    _DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) GetItemCmdKeyEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQo=</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GETIID</XNAME>
			<DESCRIPTIO><![CDATA[ITEMID  _GetItemId(MENUID menuid, long index)

This example creates a menu with three items.  It uses _GetItemId() to get the ITEMID of each menu item.  After removing one item from the menu, we see that the ITEMID is not always equal to the item index.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR GetItemIdEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_ActivateMenu(menuId);

	_PutStr("\nitemid for index 0 ="); putLong(_GetItemId(menuId, 0));
	_PutStr("\nitemid for index 1 ="); putLong(_GetItemId(menuId, 1));
	_PutStr("\nitemid for index 2 ="); putLong(_GetItemId(menuId, 2));

	_Execute("WAIT");
    _DisposeItem(menuId, _GetItemId(menuId, 1));

    _PutStr("\nitemid for index 0 ="); putLong(_GetItemId(menuId, 0));
	_PutStr("\nitemid for index 1 ="); putLong(_GetItemId(menuId, 1));

	_Execute("WAIT");
	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) GetItemIdEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjE5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMTkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GETITEXT</XNAME>
			<DESCRIPTIO><![CDATA[void  _GetItemText(MENUID menuid, ITEMID itemid, char FAR *text)

This example sets up a menu with three items and then retreives the text of each item with _GetItemText().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR GetItemTextEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;
	char FAR *itemText;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

    _ActivateMenu(menuId);

	if ((itemText = _Alloca(80)) == 0)
	{
		_Error(182); // "Insufficient memory"
	}
	_GetItemText(menuId, _GetItemId(menuId, 0), itemText);
	_PutStr("\nItem text of 1st item = "); _PutStr(itemText);

	_GetItemText(menuId, _GetItemId(menuId, 1), itemText);
	_PutStr("\nItem text of 2nd item = "); _PutStr(itemText);

	_GetItemText(menuId, _GetItemId(menuId, 2), itemText);
	_PutStr("\nItem text of 3rd item = "); _PutStr(itemText);

	_Execute("WAIT");
	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) GetItemTextEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjI4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMjguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GETNWIID</XNAME>
			<DESCRIPTIO><![CDATA[ITEMID  _GetNewItemId(MENUID menuid)

This example builds a menu with three items.  Before each item is added to the menu, a unique ITEMID is generated by calling _GetNewItemId().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR GetNewItemId(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_MenuInteract(&menuId, &itemId);

	_PutStr("\nmenuId ="); putLong(menuId);
	_PutStr("\nitemId ="); putLong(itemId);

	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) GetNewItemId, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTA3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMDcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GETNWMID</XNAME>
			<DESCRIPTIO><![CDATA[MENUID  _GetNewMenuId(void)

This example builds a menu with three items.  Before a menu can be create using _NewMenu(), a unique MENUID must be generated by calling _GetNewMenuId().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR GetNewItemId(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_MenuInteract(&menuId, &itemId);

	_PutStr("\nmenuId ="); putLong(menuId);
	_PutStr("\nitemId ="); putLong(itemId);

	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) GetNewItemId, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjYyLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjIuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GETNXEV</XNAME>
			<DESCRIPTIO><![CDATA[int  _GetNextEvent(EventRec FAR *event)

This example is a loop consisting of a call to _GetNextEvent() followed by a call to _DefaultProcess().  All events received get their default processing.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	EventRec ev;
	int i;

	for (i = 0; i < 16; i++) {
		_GetNextEvent(&ev);
        _DefaultProcess(&ev);
	}
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI)Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTQ5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNDkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GLTOLOC</XNAME>
			<DESCRIPTIO><![CDATA[void  _GlobalToLocal(Point FAR *pt, WHANDLE wh)

This example waits for a left mouse button click and then using _FindWindow() gets the window handle for the mouse position.  _GlobalToLocal() takes both the window handle and the absolute mouse position as parameters to convert the mouse position to a position relative to the window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR MyFindWindowEx(ParamBlk FAR *parm)
{
    WHANDLE wh;
	Point mousePos;
	int where;
//
//  Get mouse position when left button goes down
//
	while (_InKey(0, MOUSEACTIVE | HIDECURSOR) != 151);
	while (!_MousePos(&mousePos));

    switch (where = _FindWindow(&wh, mousePos))
    {
        case inBorder:
            _PutStr("\nMouse down inBorder"); break;
        case inHelp:
            _PutStr("\nMouse down inHelp"); break;
        case inContent:
            _PutStr("\nMouse down inContent"); break;
        case inDrag:
            _PutStr("\nMouse down inDrag"); break;
        case inGrow:
            _PutStr("\nMouse down inGrow"); break;
        case inGoAway:
            _PutStr("\nMouse down inGoAway"); break;
        case inZoom:
            _PutStr("\nMouse down inZoom"); break;
        case inVUpArrow:
            _PutStr("\nMouse down inVUpArrow"); break;
        case inVDownArrow:
            _PutStr("\nMouse down inVDownArrow"); break;
        case inVPageUp:
            _PutStr("\nMouse down inVPageUp"); break;
        case inVPageDown:
            _PutStr("\nMouse down inVPageDown"); break;
        case inVThumb:
            _PutStr("\nMouse down inVThumb"); break;
        case inHUpArrow:
            _PutStr("\nMouse down inHUpArrow"); break;
        case inHDownArrow:
            _PutStr("\nMouse down inHDownArrow"); break;
        case inHPageUp:
            _PutStr("\nMouse down inHPageUp"); break;
        case inHPageDown:
            _PutStr("\nMouse down inHPageDown"); break;
        case inHThumb:
            _PutStr("\nMouse down inHThumb"); break;
        case inMenuBar:
            _PutStr("\nMouse down inMenuBar"); break;
        default:
            _PutStr("\nMouse down someplace else"); break;
    }
	_GlobalToLocal(&mousePos, wh);
	_PutStr("\nPosition relative to window:");
	putLong(mousePos.v, 5);
	_PutChr(' ');
	putLong(mousePos.h, 5);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) MyFindWindowEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjQ5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNDkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GLTOLOCP</XNAME>
			<DESCRIPTIO><![CDATA[void  _GlobalToLocalP(Point FAR *pt, WHANDLE wh)

This example waits for a left mouse button click and then using _FindWindowP() gets the window handle for the mouse position.  _GlobalToLocalP() takes both the window handle and the absolute mouse position as parameters to convert the mouse position to a position relative to the window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR MyFindWindowEx(ParamBlk FAR *parm)
{
    WHANDLE wh;
	Point mousePos;
	int where;
//
//  Get mouse position when left button goes down
//
	while (_InKey(0, MOUSEACTIVE | HIDECURSOR) != 151);
	while (!_MousePosP(&mousePos));

	switch (where = _FindWindowP(&wh, mousePos))
    {
        case inBorder:
            _PutStr("\nMouse down inBorder"); break;
        case inHelp:
            _PutStr("\nMouse down inHelp"); break;
        case inContent:
            _PutStr("\nMouse down inContent"); break;
        case inDrag:
            _PutStr("\nMouse down inDrag"); break;
        case inGrow:
            _PutStr("\nMouse down inGrow"); break;
        case inGoAway:
            _PutStr("\nMouse down inGoAway"); break;
        case inZoom:
            _PutStr("\nMouse down inZoom"); break;
        case inVUpArrow:
            _PutStr("\nMouse down inVUpArrow"); break;
        case inVDownArrow:
            _PutStr("\nMouse down inVDownArrow"); break;
        case inVPageUp:
            _PutStr("\nMouse down inVPageUp"); break;
        case inVPageDown:
            _PutStr("\nMouse down inVPageDown"); break;
        case inVThumb:
            _PutStr("\nMouse down inVThumb"); break;
        case inHUpArrow:
            _PutStr("\nMouse down inHUpArrow"); break;
        case inHDownArrow:
            _PutStr("\nMouse down inHDownArrow"); break;
        case inHPageUp:
            _PutStr("\nMouse down inHPageUp"); break;
        case inHPageDown:
            _PutStr("\nMouse down inHPageDown"); break;
        case inHThumb:
            _PutStr("\nMouse down inHThumb"); break;
        case inMenuBar:
            _PutStr("\nMouse down inMenuBar"); break;
        default:
            _PutStr("\nMouse down someplace else"); break;
    }
	_GlobalToLocalP(&mousePos, wh);
	_PutStr("\nPosition relative to window:");
	putLong(mousePos.v, 5);
	_PutChr(' ');
	putLong(mousePos.h, 5);
}

FoxInfo myFoxInfo[] =
{
    {"ONLOAD", (FPFI)MyFindWindowEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjY4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>HANDTOPT</XNAME>
			<DESCRIPTIO><![CDATA[void FAR *  _HandToPtr(MHANDLE hand)

This example displays its character parameter on the screen.  It uses _HandToPtr() to dereference the memory handle of the API parameter to a C pointer.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void NullTerminate(Value FAR *cVal)
{
	if (!_SetHandSize(cVal->ev_handle, cVal->ev_length + 1)) {
		_Error(182); // "Insufficient memory"
	}
	((char FAR *) _HandToPtr(cVal->ev_handle))[cVal->ev_length] = '\0';
}

void FAR Example(ParamBlk FAR *parm)
{
	NullTerminate(&parm->p[0].val);
    _HLock(parm->p[0].val.ev_handle);

	_PutStr(_HandToPtr(parm->p[0].val.ev_handle));

	_HUnLock(parm->p[0].val.ev_handle);
}
FoxInfo myFoxInfo[] = {
	{"HANDTOPTR", (FPFI) Example, 1, "C"},
};
FoxTable _FoxTable = {
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= HANDTOPTR("Hello, world.")  && displays "Hello, world" on screen
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDkzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwOTMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>HLOCK</XNAME>
			<DESCRIPTIO><![CDATA[void  _HLock(MHANDLE hand)

This example displays its character parameter on the screen.  It uses _HandToPtr() to dereference the memory handle of the API parameter to a C pointer.  Because during the call to _PutStr() FoxPro may "decided" to reorganize memory, to insure proper execution we should call _HLock() on the memory handle.  We are careful to _HUnLock() after we are done, because the performance of FoxPro can be adversely affected by locked memory handles.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void NullTerminate(Value FAR *cVal)
{
	if (!_SetHandSize(cVal->ev_handle, cVal->ev_length + 1)) {
		_Error(182); // "Insufficient memory"
	}
	((char FAR *) _HandToPtr(cVal->ev_handle))[cVal->ev_length] = '\0';
}
void FAR Example(ParamBlk FAR *parm)
{
	NullTerminate(&parm->p[0].val);
    _HLock(parm->p[0].val.ev_handle);
	_PutStr(_HandToPtr(parm->p[0].val.ev_handle));
	_HUnLock(parm->p[0].val.ev_handle);
}
FoxInfo myFoxInfo[] = {
	{"HLOCK", (FPFI) Example, 1, "C"},
};
FoxTable _FoxTable = {
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= HLOCK("Hello, world.") && displays "Hello, world" on screen
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjYzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>HUNLOCK</XNAME>
			<DESCRIPTIO><![CDATA[void  _HUnLock(MHANDLE hand)

This example uses _RetDateStr() to return a FoxPro date type assuming that the character parameter is a proper date.  We are careful to _HUnLock() memory handles when they no longer need to be locked, because the performance of FoxPro can be adversely affected by locked memory handles.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR dates(ParamBlk FAR *parm)
{
    MHANDLE mh;
    char FAR *instring;

	if ((mh = _AllocHand(parm->p[0].val.ev_length + 1)) == 0) {
		_Error(182); // "Insufficient memory"
	}
	_HLock(mh);
	instring = _HandToPtr(mh);
	_MemMove(instring,_HandToPtr(parm->p[0].val.ev_handle),parm->p[0].val.ev_length);
	instring[parm->p[0].val.ev_length] = '\0';
	_RetDateStr(instring);
	_HUnLock(mh);
}
FoxInfo myFoxInfo[] = {
	{"DATES", (FPFI) dates, 1, "C"}
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? DATES("2/14/93")  && returns date {02/14/93}
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwNzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>INKEY</XNAME>
			<DESCRIPTIO><![CDATA[int  _InKey(int timeout, int flag)

This example shows the API function being called from FoxPro with two _InKey() flags being logically "orred."]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_RetInt(_InKey((int) parm->p[0].val.ev_long,
		(int) parm->p[1].val.ev_long), 10);
}
FoxInfo myFoxInfo[] = {
	{"XINKEY", (FPFI) Example, 2, "I,I"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
#define SHOWCURSOR	1
#define HIDECURSOR	2
#define MOUSEACTIVE 4
= XINKEY(0, SHOWCURSOR + MOUSEACTIVE)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>LOAD</XNAME>
			<DESCRIPTIO><![CDATA[int  _Load(Locator FAR *loc, Value FAR *val)

This example converts to upper case a string argument passed by reference.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Upper(ParamBlk FAR *parm)
{
		char FAR *pString;
		Value val;
		unsigned int i;
//
//	_Load() and _Store are the functions of interest for pass-by-reference.
//
	_Load(&parm->p[0].loc, &val);
//
//	FoxPro doesn't check the type of pass-by-reference arguments, so we do.
//
    if (val.ev_type != 'C')
	{
		_Error(9); // "Data type mismatch"
	}
    pString = _HandToPtr(val.ev_handle);

	for (i = 0; i < val.ev_length; i++)
	{
		if ('a' <= *pString && *pString <= 'z')
		{
			*pString += ('A' - 'a');
		}
		pString++;
	}
	_Store(&parm->p[0].loc, &val);
	//
	// We need to free the handle that we created with  _LOAD()
	//
	_FreeHand(val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"XUPPER", (FPFI) Upper, 1, "R"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
x = "abc"
= XUPPER(@x)
? x
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjM3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMzcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MEMAVAIL</XNAME>
			<DESCRIPTIO><![CDATA[int  _MemAvail(unsigned int size)

This example builds a linked list of 1K memory allocations exhausting available memory.  It frees allocations (of course) and returns the number of allocations made.  _MemAvail() is used to terminate the first while-loop.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

#define ALLOCSIZE 1024

void FAR Example(ParamBlk FAR *parm)
{
	int nHandles = 0;
	MHANDLE head = 0, mh;
    while (_MemAvail(ALLOCSIZE)) {
        mh = _AllocHand(ALLOCSIZE);
		*((MHANDLE *) _HandToPtr(mh)) = head;
		head = mh;
		nHandles++;
    }
	_RetInt(nHandles, 10);
    while (head != 0) {
		mh = *((MHANDLE *) _HandToPtr(head));
		_FreeHand(head);
		head = mh;
	}
}
FoxInfo myFoxInfo[] = {
	{"MEMAVAIL", (FPFI) Example, 0, ""},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? MEMAVAIL()  && displays approx. memory available in K
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjY0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MEMCMP</XNAME>
			<DESCRIPTIO><![CDATA[int  _MemCmp(void FAR *ptr1, void FAR *ptr2, unsigned int length)

This example uses _MemCmp() to compare two character parameters up to length of the shorter.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

#ifndef min
#define min(a, b) ((a) < (b) ? (a) : (b))
#endif

void FAR Example(ParamBlk FAR *parm)
{
	int LenToCmp, RetValue;

	LenToCmp = min(parm->p[0].val.ev_length, parm->p[1].val.ev_length);

    _HLock(parm->p[0].val.ev_handle);
	_HLock(parm->p[1].val.ev_handle);

	RetValue = _MemCmp(_HandToPtr(parm->p[0].val.ev_handle),
		_HandToPtr(parm->p[1].val.ev_handle), LenToCmp);

	_RetInt(RetValue, 10); // does return control here

    _HUnLock(parm->p[0].val.ev_handle);
	_HUnLock(parm->p[1].val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"MEMCMP", (FPFI) Example, 2, "C,C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? MEMCMP("Hello, world.", "Hello, world.")  && returns 0
? MEMCMP("Hello, world.", "Hello, wurld.")  && returns non-0
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTUxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNTEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MEMFILL</XNAME>
			<DESCRIPTIO><![CDATA[void  _MemFill(void FAR *ptr, int character, unsigned int length)

This example uses _MemFill() to duplicate the functionality of the FoxPro function REPLICATE().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	char FAR *rep;
	char c = *(char *) _HandToPtr(parm->p[0].val.ev_handle);

	rep = _Alloca((int) parm->p[1].val.ev_long + 1);

	_MemFill(rep, c, (int) parm->p[1].val.ev_long);

    rep[parm->p[1].val.ev_long] = '\0';
	_RetChar(rep);
}
FoxInfo myFoxInfo[] = {
	{"XREPLICATE", (FPFI) Example, 2, "C,I"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
x = xREPLICATE("x", 120)
? x
? LEN(x)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTc3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNzcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MEMMOVE</XNAME>
			<DESCRIPTIO><![CDATA[void  _MemMove(void FAR *dest, void FAR *src, unsigned int length)

This example uses _MemMove() to implement a substring function.  From FoxPro MEMMOVE(s, n1, n2) extracts the substring of s from position n1 to position n2.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	int SubstrLen;
	MHANDLE bufferHandle;
	char FAR *FirstDest;

	SubstrLen = parm->p[2].val.ev_long - parm->p[1].val.ev_long + 1;
	if ((bufferHandle = _AllocHand(SubstrLen + 1)) == 0) {
		_Error(182); // "Insufficient memory"
	}
	_HLock(bufferHandle);
	_HLock(parm->p[0].val.ev_handle);
	FirstDest = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle) +
		parm->p[1].val.ev_long - 1;

	_MemMove(_HandToPtr(bufferHandle), FirstDest, SubstrLen);

	((char FAR *) _HandToPtr(bufferHandle))[SubstrLen] = '\0';
	_RetChar(_HandToPtr(bufferHandle));
	_HUnLock(bufferHandle);
	_HUnLock(parm->p[0].val.ev_handle);
}
FoxInfo myFoxInfo[] = {
	{"MEMMOVE", (FPFI) Example, 3, "C,I,I"},
};
FoxTable _FoxTable = {
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? MEMMOVE("Hello, world.", 8, 10)  && returns "wor"
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjA0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMDQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MEMOCHAN</XNAME>
			<DESCRIPTIO><![CDATA[FCHAN  _MemoChan(int workarea)

This example retrieves the contents of a memo field.  _MemoChan(-1) returns a FCHAN to the memo file for the current work area.  This FCHAN is used as an argument to the low level file I/O API callbacks.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR FindMemoEx(ParamBlk FAR *parm)
{

	Locator FAR *memoFldLoc;
	FCHAN fchMemo;
	char FAR *memoContents;
	int memoLen;
	long loc;

	if ((fchMemo = _MemoChan(-1)) == -1)
	{
		_UserError("_MemoChan() failed");
	}
    memoFldLoc = &parm->p[0].loc;

	if ((loc = _FindMemo(memoFldLoc)) < 0)
	{
		_UserError("_FindMemo() failed");
	}
	if ((memoLen = _MemoSize(memoFldLoc)) < 0)
	{
		_UserError("_MemoSize() failed");
	}
	if ((memoContents = _Alloca(memoLen + 1)) == 0)
	{
		_Error(182); // "Insufficient memory"
	}
    _FSeek(fchMemo, loc, FS_FROMBOF);
	_FRead(fchMemo, memoContents, memoLen);
	memoContents[memoLen] = '\0';
	_RetChar(memoContents);
}

FoxInfo myFoxInfo[] =
{
	{"GETMEMO", (FPFI) FindMemoEx, 1, "R"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
CREATE TABLE WMemo (MemoField M)
APPEND BLANK
REPLACE MemoField WITH "Hello, World."
? GETMEMO(@MemoField)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjUxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNTEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MEMOSIZE</XNAME>
			<DESCRIPTIO><![CDATA[long  _MemoSize(Locator FAR *fld)

This example retrieves the contents of a memo field.  We call _MemoSize() to determine how much memory should be allocated for a buffer and how many bytes should be read from the memo file.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR FindMemoEx(ParamBlk FAR *parm)
{

	Locator FAR *memoFldLoc;
	FCHAN fchMemo;
	char FAR *memoContents;
	int memoLen;
	long loc;

	if ((fchMemo = _MemoChan(-1)) == -1)
	{
		_UserError("_MemoChan() failed");
	}
    memoFldLoc = &parm->p[0].loc;

	if ((loc = _FindMemo(memoFldLoc)) < 0)
	{
		_UserError("_FindMemo() failed");
	}
	if ((memoLen = _MemoSize(memoFldLoc)) < 0)
	{
		_UserError("_MemoSize() failed");
	}
	if ((memoContents = _Alloca(memoLen + 1)) == 0)
	{
		_Error(182); // "Insufficient memory"
	}
    _FSeek(fchMemo, loc, FS_FROMBOF);
	_FRead(fchMemo, memoContents, memoLen);
	memoContents[memoLen] = '\0';
	_RetChar(memoContents);
}

FoxInfo myFoxInfo[] =
{
	{"GETMEMO", (FPFI) FindMemoEx, 1, "R"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
CREATE TABLE WMemo (MemoField M)
APPEND BLANK
REPLACE MemoField WITH "Hello, World."
? GETMEMO(@MemoField)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjY2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MENUID</XNAME>
			<DESCRIPTIO><![CDATA[MENUID  _MenuId(long literal)

This example adds a pad to the system menu.  It then attaches a popup menu with two items to this pad.  _MenuId() is used to obtain the MENUID of the system menu.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

MENUID SysMenuId;
MENUID PopupId;
ITEMID PadId;

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

FAR onSelection(long menuId, long itemId)
{
	_PutStr("\nitemId = "); putLong(itemId);
	return 0;
}

void FAR StartUp()
{
		ITEMID Bar1Id;
		ITEMID Bar2Id;

        int Error;
//
//	Add new pad to SYSMENU.
//
    SysMenuId = _MenuId(_SYSMENU);
    PadId = _GetNewItemId(SysMenuId);

	if (_NewItem(SysMenuId, PadId, _LASTITEM, "\\<Added pad"))
    {
        _Error(623); /* "Menu item cannot be defined." */
    }
//
//	Define popup menu.
//
    PopupId = _GetNewMenuId();

    if (Error = _NewMenu(MPOPUP, PopupId))
    {
        _Error(-Error);
    }
	Bar1Id = _GetNewItemId(PopupId);
//
//		WARNING: Call _NewItem() before another _GetNewItemId().
//
	if (_NewItem(PopupId, Bar1Id, _LASTITEM, "\\<1st item"))
    {
        _Error(623); /* "Menu item cannot be defined." */
    }
	Bar2Id = _GetNewItemId(PopupId);

	if (_NewItem(PopupId, Bar2Id, _LASTITEM, "\\<2nd item"))
    {
        _Error(623); /* "Menu item cannot be defined." */
    }
//
//	Attach popup to pad.
//
    _SetItemSubMenu(SysMenuId, PadId, PopupId);
//
//  Set up selection action.
//
	_OnSelection(PopupId, -1, onSelection);
}

void FAR ShutDown()
{
    _DisposeItem(SysMenuId, PadId);
    _DisposeMenu(PopupId);
}

FoxInfo myFoxInfo[] =
{
	{"STARTUP",     (FPFI) StartUp,    CALLONLOAD,   ""},
	{"SHUTDOWN",    (FPFI) ShutDown,   CALLONUNLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjQ0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNDQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MENUINTE</XNAME>
			<DESCRIPTIO><![CDATA[int  _MenuInteract(MENUID FAR *menuid, ITEMID FAR *itemid)

This example builds a menu with three items and then requires the user to interact with the menu by calling _MenuInteract().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR GetNewItemId(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_MenuInteract(&menuId, &itemId);

	_PutStr("\nmenuId ="); putLong(menuId);
	_PutStr("\nitemId ="); putLong(itemId);

	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) GetNewItemId, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDM5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwMzkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MOUSEPOS</XNAME>
			<DESCRIPTIO><![CDATA[int  _MousePos(Point FAR *pt)

This example displays the current mouse position until it detects a left mouse button click.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR MousePosEx(ParamBlk FAR *parm)
{
	Point mousePos;

	while (!_MousePos(&mousePos))
	{
		_PutStr("\nvertical =");
		putLong(mousePos.v, 5);
		_PutStr("; horizontal =");
		putLong(mousePos.h, 5);
	}
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) MousePosEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDg3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwODcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>MOUSEPOP</XNAME>
			<DESCRIPTIO><![CDATA[int  _MousePosP(Point FAR *pt)

This example displays the current mouse position until it detects a left mouse button click.]]></DESCRIPTIO>
			<C_CODE><![CDATA[
#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR MousePosPEx(ParamBlk FAR *parm)
{
	Point mousePos;

	while (!_MousePosP(&mousePos))
	{
		_PutStr("\nvertical =");
		putLong(mousePos.v, 5);
		_PutStr("; horizontal =");
		putLong(mousePos.h, 5);
	}
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) MousePosPEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTQwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNDAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>NTI</XNAME>
			<DESCRIPTIO><![CDATA[NTI  _NameTableIndex(char FAR *name)

This example releases a memory variable whose name is given as a character argument.  Note that _NameTableIndex() this finds the variable name after it has been released.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR ReleaseEx(ParamBlk FAR *parm)
{
	NTI nti;
	char FAR *name;
	int exitCode;
	Locator loc;
//
//	Null terminate character string, name of variable
//
	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);
	name = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	name[parm->p[0].val.ev_length] = '\0';

	if ((nti = _NameTableIndex(name)) == -1)
	{
		_HUnLock(parm->p[0].val.ev_handle);
		_UserError("Cannot find variable in name table.");
	}
	_HUnLock(parm->p[0].val.ev_handle);

    if (_FindVar(nti, -1, &loc))
	{
		_PutStr("\nVariable exists prior to _Release().");
	}
    if ((exitCode =_Release(nti)) < 0)
	{
		_Error(-exitCode);
	}

    _HLock(parm->p[0].val.ev_handle);
	name = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	name[parm->p[0].val.ev_length] = '\0';

	if ((nti = _NameTableIndex(name)) != -1)
	{
		_PutStr("\n_NameTableIndex() still finds variable after it is released.");
	}
	_HUnLock(parm->p[0].val.ev_handle);

	if (!_FindVar(nti, -1, &loc))
	{
		_PutStr("\nVariable does not exist after _Release().");
	}
}

FoxInfo myFoxInfo[] =
{
	{"XRELEASE", (FPFI) ReleaseEx, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
x = 123
= XRELEASE("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTkzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxOTMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>NEWITEM</XNAME>
			<DESCRIPTIO><![CDATA[int  _NewItem(MENUID menuid, ITEMID itemid, ITEMID beforeid, char FAR *prompt)

This example builds a menu with three items.  _NewItem() is used to add each item to the menu.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR GetNewItemId(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -1, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_MenuInteract(&menuId, &itemId);

	_PutStr("\nmenuId ="); putLong(menuId);
	_PutStr("\nitemId ="); putLong(itemId);

	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) GetNewItemId, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjQzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNDMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>NEWMENU</XNAME>
			<DESCRIPTIO><![CDATA[int  _NewMenu(int mtype, MENUID menuid)

This example creates a popup menu.  _NewMenu() is used to create the menu specifying that we desire a popup type menu.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR GetNewItemId(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -1, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_MenuInteract(&menuId, &itemId);

	_PutStr("\nmenuId ="); putLong(menuId);
	_PutStr("\nitemId ="); putLong(itemId);

	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) GetNewItemId, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjYxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>NEWVAR</XNAME>
			<DESCRIPTIO><![CDATA[int  _NewVar(char FAR *name, Locator FAR *loc, int flag)

This example uses _NewVar() to create three variables.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR NewVarEx(ParamBlk FAR *parm)
{
	char FAR *varName;
	Locator loc;
	int flag;
	int retValue;
//
//	Null terminate character string
//
	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1)) {
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);
	varName = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	varName[parm->p[0].val.ev_length] = '\0';
    loc.l_subs = (int) parm->p[1].val.ev_long;
    loc.l_sub1 = (int) parm->p[2].val.ev_long;
    loc.l_sub2 = (int) parm->p[3].val.ev_long;
    flag = parm->p[4].val.ev_long;
	if ((retValue = _NewVar(varName, &loc, flag)) < 0) {
		_Error(-retValue); // _NewVar() returns negative FoxPro error number
	}
    _HUnLock(parm->p[0].val.ev_handle);
}
FoxInfo myFoxInfo[] = {
	{"XNEWVAR", (FPFI) NewVarEx, 5, "C,I,I,I,I"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
*
*   As defined in "pro_ext.h"
*
#define NV_PUBLIC		0
#define NV_PRIVATE	1

= xNewVar('var', 0, 0, 0, NV_PUBLIC)
DISPLAY MEMORY LIKE var

= xNewVar('onedim', 1, 5, 0, NV_PUBLIC)
DISPLAY MEMORY LIKE onedim

= xNewVar('twodim', 2, 5, 6, NV_PUBLIC)
DISPLAY MEMORY LIKE twodim
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTcxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNzEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>ONSELECT</XNAME>
			<DESCRIPTIO><![CDATA[void  _OnSelection(MENUID menuid, ITEMID itemid, FPFI routine)

This example creates a menu with three items.  _OnSelection() is called with a ITEMID parameter of -1 indicating that the function onSelection() is to be called when any item from this menu is selected.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

FAR onSelection(long menuId, long itemId)
{
	_PutStr("\nitemId = "); putLong(itemId);
	_DisposeMenu(menuId);
	return 0;
}

void FAR activateMenu(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

    _ActivateMenu(menuId);
	_OnSelection(menuId, -1, onSelection);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) activateMenu, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTgxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>PUTCHR</XNAME>
			<DESCRIPTIO><![CDATA[void  _PutChr(int char)

This example uses _PutChr() to write all 8-bit characters to the screen.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	int ch;

	for (ch = 0; ch < 256; ch++)
	{
		_PutChr(ch);
	}
}

FoxInfo myFoxInfo[] =
{
	{"PUTCHR", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjgyLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODIuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>PUTSTR</XNAME>
			<DESCRIPTIO><![CDATA[void  _PutStr(char FAR *str)

This example uses _PutStr() to display its character type parameter in upper case on the screen.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include "pro_ext.h"

void NullTerminate(Value FAR *cVal)
{
	if (!_SetHandSize(cVal->ev_handle, cVal->ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	((char FAR *) _HandToPtr(cVal->ev_handle))[cVal->ev_length] = '\0';
}

void FAR Example(ParamBlk FAR *parm)
{
		char FAR *pString;
		unsigned int i;

	NullTerminate(&parm->p[0].val);
	pString = _HandToPtr(parm->p[0].val.ev_handle);
	for (i = 0; i < parm->p[0].val.ev_length; i++)
	{
		if ('a' <= *pString && *pString <= 'z')
		{
			*pString += ('A' - 'a');
		}
		pString++;
	}
	_HLock(parm->p[0].val.ev_handle);
	_PutStr(_HandToPtr(parm->p[0].val.ev_handle));
	_HUnLock(parm->p[0].val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"XUPPER", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= XUPPER("upper")  && displays "UPPER" on the screen
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTY1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNjUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>PUTVALUE</XNAME>
			<DESCRIPTIO><![CDATA[void  _PutValue(Value FAR *val)

This example uses _PutValue() to display its character type parameter in upper case on the screen.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include "pro_ext.h"

void NullTerminate(Value FAR *cVal)
{
	if (!_SetHandSize(cVal->ev_handle, cVal->ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	((char FAR *) _HandToPtr(cVal->ev_handle))[cVal->ev_length] = '\0';
}

void FAR Example(ParamBlk FAR *parm)
{
	char FAR *pString;
	unsigned int i;

	NullTerminate(&parm->p[0].val);
	pString = _HandToPtr(parm->p[0].val.ev_handle);
	for (i = 0; i < parm->p[0].val.ev_length; i++)
	{
		if ('a' <= *pString && *pString <= 'z')
		{
			*pString += ('A' - 'a');
		}
		pString++;
	}
	_PutValue(&parm->p[0].val);
}

FoxInfo myFoxInfo[] =
{
	{"XUPPER", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= XUPPER("upper")  && displays "UPPER" on screen
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjkzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyOTMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>RELEASE</XNAME>
			<DESCRIPTIO><![CDATA[int  _Release(NTI n)

This example releases a memory variable whose name is given as a character argument.  _NameTableIndex() is used to find the NTI of the variable.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR ReleaseEx(ParamBlk FAR *parm)
{
	NTI nti;
	char FAR *name;
	int exitCode;
	Locator loc;
//
//	Null terminate character string, name of variable
//
	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);
	name = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	name[parm->p[0].val.ev_length] = '\0';

	if ((nti = _NameTableIndex(name)) == -1)
	{
		_HUnLock(parm->p[0].val.ev_handle);
		_UserError("Cannot find variable in name table.");
	}
	_HUnLock(parm->p[0].val.ev_handle);

    if (_FindVar(nti, -1, &loc))
	{
		_PutStr("\nVariable exists prior to _Release().");
	}
    if ((exitCode =_Release(nti)) < 0)
	{
		_Error(-exitCode);
	}

    _HLock(parm->p[0].val.ev_handle);
	name = (char FAR *) _HandToPtr(parm->p[0].val.ev_handle);
	name[parm->p[0].val.ev_length] = '\0';

	if ((nti = _NameTableIndex(name)) != -1)
	{
		_PutStr("\n_NameTableIndex() still finds variable after it is released.");
	}
	_HUnLock(parm->p[0].val.ev_handle);

	if (!_FindVar(nti, -1, &loc))
	{
		_PutStr("\nVariable does not exist after _Release().");
	}
}

FoxInfo myFoxInfo[] =
{
	{"XRELEASE", (FPFI) ReleaseEx, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
x = 123
= XRELEASE("x")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTQxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNDEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>RETCHAR</XNAME>
			<DESCRIPTIO><![CDATA[void  _RetChar(char FAR *string)

]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR chars(ParamBlk FAR *parm)
{
	char message[] = "Hello, world";
	_RetChar(message);
}
FoxInfo myFoxInfo[] = {
	{"CHARS", (FPFI) chars, 0, ""}
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>RETFLOAT</XNAME>
			<DESCRIPTIO><![CDATA[void  _RetFloat(double flt,  int width, int dec)

This example use _RetFloat() to return the floating point representation of a FoxPro date parameter.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_RetFloat(parm->p[0].val.ev_real, 20, 4);
}

FoxInfo myFoxInfo[] =
{
	{"RETFLOAT", (FPFI) Example, 1, "D"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? RETFLOAT({2/14/93})  && returns floating point representation of date {2/14/93}
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjE1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMTUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>RETINT</XNAME>
			<DESCRIPTIO><![CDATA[void  _RetInt(long ival, int width)

This example performs some operations on the DBF in the current work area.  It returns the value returned by _RecCount() using _RetInt().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include  <pro_ext.h>
#define nl _PutChr('\n')

long FAR CTest()
{
	long rc,rec;
	int workarea = -1;
	int flag = 0;
	int rn;

	rc = _DBRewind(workarea);
	_PutStr("top");  nl;
	rc = _DBSkip(workarea, 5);
	_PutStr("skipped 5");  nl;
	
	rc = _DBAppend(workarea,flag);
	_PutStr("Appending");   nl;
	rc = _DBRewind(workarea);
	_PutStr("top");  nl;
	rn = _DBRecCount(workarea);
	_RetInt(rn, 10);
	rec = rn;
	return rn;
}

FoxInfo myFoxInfo[] ={
	{"CTEST", (FPFI) CTest,0 , ""},
};


FoxTable _FoxTable = {
	(FoxTable FAR *)0, sizeof(myFoxInfo) / sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDY0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwNjQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>RETLOGIC</XNAME>
			<DESCRIPTIO><![CDATA[void  _RetLogical(int flag)

This example is coin flip.  It returns .T. or .F. based on library function rand().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	_RetLogical(rand() % 2);
}

FoxInfo myFoxInfo[] =
{
	{"RETLOGICAL", (FPFI) Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? RETLOGICAL()  && returns .T. or .F. pseudo-randomly
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjczLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>RETVAL</XNAME>
			<DESCRIPTIO><![CDATA[void  _RetVal(Value FAR *val)

This example uses _RetVal() to return its character type parameter converted to upper case.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include "pro_ext.h"

void NullTerminate(Value FAR *cVal)
{
	if (!_SetHandSize(cVal->ev_handle, cVal->ev_length + 1)) {
		_Error(182); // "Insufficient memory"
	}
	((char FAR *) _HandToPtr(cVal->ev_handle))[cVal->ev_length] = '\0';
}

void FAR Example(ParamBlk FAR *parm)
{
	char FAR *pString;
	unsigned int i;

	NullTerminate(&parm->p[0].val);
	pString = _HandToPtr(parm->p[0].val.ev_handle);
	for (i = 0; i < parm->p[0].val.ev_length; i++) {
		if ('a' <= *pString && *pString <= 'z') {
			*pString += ('A' - 'a');
		}
		pString++;
	}
	_RetVal(&parm->p[0].val);
}
FoxInfo myFoxInfo[] = {
	{"XUPPER", (FPFI) Example, 1, "C"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? XUPPER("upper")  && returns "UPPER"
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjkxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyOTEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>SETMNCOL</XNAME>
			<DESCRIPTIO><![CDATA[void  _Set MenuColor(MENUID menuid, int scheme)

This example creates a menu with three items in a color scheme specified by the calling parameter.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR SetMenuColorEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);
	_SetMenuColor(menuId, (int) parm->p[0].val.ev_long);

    itemId = _GetNewItemId(menuId);
    _NewItem(menuId, itemId, -2, "\\<1st item");

    itemId = _GetNewItemId(menuId);
    _NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_MenuInteract(&menuId, &itemId);
	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"MENUCOLOR", (FPFI) SetMenuColorEx, 1, "I"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= MENUCOLOR(1)
= MENUCOLOR(6)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTg1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>SETHANDS</XNAME>
			<DESCRIPTIO><![CDATA[int  _SetHandSize(MHANDLE hand, unsigned int size)

This example uses _HandToPtr() to dereference a pass-by-value parameter from FoxPro to a C pointer.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void NullTerminate(Value FAR *cVal)
{
	if (!_SetHandSize(cVal->ev_handle, cVal->ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	((char FAR *) _HandToPtr(cVal->ev_handle))[cVal->ev_length] = '\0';
}

void FAR Example(ParamBlk FAR *parm)
{
	NullTerminate(&parm->p[0].val);

    _HLock(parm->p[0].val.ev_handle);
	_PutStr(_HandToPtr(parm->p[0].val.ev_handle));
	_HUnLock(parm->p[0].val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"HANDTOPTR", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= HANDTOPTR("Hello, world.") && displays "Hello, world" on screen
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>SETICMDK</XNAME>
			<DESCRIPTIO><![CDATA[void  _SetItemCmdKey(MENUID menuid, ITEMID itemid, int key, char FAR *text)

This example sets up a menu with three items and assigns a keyboard short cut to each item.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

FAR onSelection(long menuId, long itemId)
{
	_PutStr("\nitemId = "); putLong(itemId);
	_DisposeMenu(menuId);
	return 0;
}

void FAR SetItemCmdKeyEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");
	_SetItemCmdKey(menuId, itemId, altKey | 0x178, "Alt+1");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");
	_SetItemCmdKey(menuId, itemId, altKey | 0x179, "Alt+2");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");
	_SetItemCmdKey(menuId, itemId, altKey | 0x17a, "Alt+3");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

    _ActivateMenu(menuId);
	_OnSelection(menuId, -1, onSelection);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) SetItemCmdKeyEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjMwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMzAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>SETICOLO</XNAME>
			<DESCRIPTIO><![CDATA[void  _SetItemColor(MENUID menuid, ITEMID itemid, int scheme)

In this example each of the three items is display in a different color scheme.  Real pretty?!]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

void FAR GetNewItemId(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

    itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");
	_SetItemColor(menuId, itemId, ALERT_SCHEME);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");
	_SetItemColor(menuId, itemId, DIALOG_SCHEME);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");
	_SetItemColor(menuId, itemId, WINDOW_SCHEME);

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

	_MenuInteract(&menuId, &itemId);

	_PutStr("\nmenuId ="); putLong(menuId);
	_PutStr("\nitemId ="); putLong(itemId);

	_DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) GetNewItemId, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjY1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>SETISUBM</XNAME>
			<DESCRIPTIO><![CDATA[void  _SetItemSubMenu(MENUID menuid, ITEMID itemid, MENUID submenuid)

This example adds a pad to the system menu.  Using _SetItemSubMenu(), It then attaches a popup menu with two items to this pad.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

MENUID SysMenuId;
MENUID PopupId;
ITEMID PadId;

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

FAR onSelection(long menuId, long itemId)
{
	_PutStr("\nitemId = "); putLong(itemId);
	return 0;
}

void FAR StartUp()
{
		ITEMID Bar1Id;
		ITEMID Bar2Id;

        int Error;
//
//	Add new pad to SYSMENU.
//
    SysMenuId = _MenuId(_SYSMENU);
    PadId = _GetNewItemId(SysMenuId);

	if (_NewItem(SysMenuId, PadId, _LASTITEM, "\\<Added pad"))
    {
        _Error(623); /* "Menu item cannot be defined." */
    }
//
//	Define popup menu.
//
    PopupId = _GetNewMenuId();

    if (Error = _NewMenu(MPOPUP, PopupId))
    {
        _Error(-Error);
    }
	Bar1Id = _GetNewItemId(PopupId);
//
//		WARNING: Call _NewItem() before another _GetNewItemId().
//
	if (_NewItem(PopupId, Bar1Id, _LASTITEM, "\\<1st item"))
    {
        _Error(623); /* "Menu item cannot be defined." */
    }
	Bar2Id = _GetNewItemId(PopupId);

	if (_NewItem(PopupId, Bar2Id, _LASTITEM, "\\<2nd item"))
    {
        _Error(623); /* "Menu item cannot be defined." */
    }
//
//	Attach popup to pad.
//
    _SetItemSubMenu(SysMenuId, PadId, PopupId);
//
//  Set up selection action.
//
	_OnSelection(PopupId, -1, onSelection);
}

void FAR ShutDown()
{
    _DisposeItem(SysMenuId, PadId);
    _DisposeMenu(PopupId);
}

FoxInfo myFoxInfo[] =
{
	{"STARTUP",     (FPFI) StartUp,    CALLONLOAD,   ""},
	{"SHUTDOWN",    (FPFI) ShutDown,   CALLONUNLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>SETITEXT</XNAME>
			<DESCRIPTIO><![CDATA[void  _SetItemText(MENUID menuid, ITEMID itemid, char FAR *text)

This example builds a menu with three items.  It then changes the item text using _SetItemText().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR SetItemTextEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);

    _ActivateMenu(menuId);
	_Execute("WAIT WINDOW 'Original item text'");

	_SetItemText(menuId, _GetItemId(menuId, 0), "This was the 1st item");
    _SetItemText(menuId, _GetItemId(menuId, 1), "This was the 2nd item");
	_SetItemText(menuId, _GetItemId(menuId, 2), "This was the 3rd item");

	_Execute("WAIT WINDOW 'New item text'");
    _DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) SetItemTextEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>SETMNPNT</XNAME>
			<DESCRIPTIO><![CDATA[void  _SetMenuPoint(MENUID menuid, Point loc)

A menu is created and then activated at three different positions specified by _SetMenuPoint().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR SetMenuPointEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 10; loc.h = 20;
	_SetMenuPoint(menuId, loc);
	_MenuInteract(&menuId, &itemId);

	loc.v = 15; loc.h = 30;
	_SetMenuPoint(menuId, loc);
	_MenuInteract(&menuId, &itemId);

	loc.v = 20; loc.h = 40;
	_SetMenuPoint(menuId, loc);
	_MenuInteract(&menuId, &itemId);

    _DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) SetMenuPointEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTU4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNTguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>SETMNPTP</XNAME>
			<DESCRIPTIO><![CDATA[void  _SetMenuPointP(MENUID menuid, Point loc)

A menu is created and then activated at three different positions specified by _SetMenuPointP().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR SetMenuPointPEx(ParamBlk FAR *parm)
{
	MENUID menuId;
	ITEMID itemId;
	Point loc;

	menuId = _GetNewMenuId();
	_NewMenu(MPOPUP, menuId);

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<1st item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<2nd item");

	itemId = _GetNewItemId(menuId);
	_NewItem(menuId, itemId, -2, "\\<3rd item");

	loc.v = 40; loc.h = 80;
	_SetMenuPointP(menuId, loc);
	_MenuInteract(&menuId, &itemId);

	loc.v = 80; loc.h = 160;
	_SetMenuPointP(menuId, loc);
	_MenuInteract(&menuId, &itemId);

	loc.v = 160; loc.h = 320;
	_SetMenuPointP(menuId, loc);
	_MenuInteract(&menuId, &itemId);

    _DisposeMenu(menuId);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI)SetMenuPointPEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjk4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyOTguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>STORE</XNAME>
			<DESCRIPTIO><![CDATA[int  _Store(Locator FAR *loc, Value FAR *val)

This example converts to upper case a string argument passed by reference.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Upper(ParamBlk FAR *parm)
{
		char FAR *pString;
		Value val;
		unsigned int i;
//
//	_Load() and _Store are the functions of interest for pass-by-reference.
//
	_Load(&parm->p[0].loc, &val);
//
//	FoxPro doesn't check the type of pass-by-reference arguments, so we do.
//
	if (val.ev_type != 'C') {
		_Error(9); // "Data type mismatch"
	}
    pString = _HandToPtr(val.ev_handle);

	for (i = 0; i < val.ev_length; i++)  {
		if ('a' <= *pString && *pString <= 'z') {
			*pString += ('A' - 'a');
		}
		pString++;
	}
	_Store(&parm->p[0].loc, &val);
	//
	// We need to free the handle that we created with  _LOAD()
	//
	_FreeHand(val.ev_handle);

}
FoxInfo myFoxInfo[] = {
	{"XUPPER", (FPFI) Upper, 1, "R"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
x = "abc"
= XUPPER(@x)
? x
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjA0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMDQuDQpMSU5LIDogZmF0YWwgZXJyb3IgTE5LMTEwNDogY2Fubm90IG9wZW4gZmlsZSAiLlxleGFtcGxlLmZsbCINCg0KQlVJTEQgU1VDQ0VFREVE</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>STRCMP</XNAME>
			<DESCRIPTIO><![CDATA[int  _StrCmp(char FAR *string1, char FAR *string2)

This example uses _StrCmp() to compare two FoxPro strings passed as parameters.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void NullTerminate(Value FAR *cVal)
{
	if (!_SetHandSize(cVal->ev_handle, cVal->ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	((char FAR *) _HandToPtr(cVal->ev_handle))[cVal->ev_length] = '\0';
}

void FAR Example(ParamBlk FAR *parm)
{
	int RetValue;

    NullTerminate(&parm->p[0].val);
	NullTerminate(&parm->p[1].val);

    _HLock(parm->p[0].val.ev_handle);
	_HLock(parm->p[1].val.ev_handle);

	RetValue = _StrCmp(_HandToPtr(parm->p[0].val.ev_handle),
		_HandToPtr(parm->p[1].val.ev_handle));

	_RetInt(RetValue, 10); // does return control here

    _HUnLock(parm->p[0].val.ev_handle);
	_HUnLock(parm->p[1].val.ev_handle);
}

FoxInfo myFoxInfo[] =
{
	{"STRCMP", (FPFI) Example, 2, "C,C"},
};

FoxTable _FoxTable =
{
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? STRCMP("Hello, world.", "Hello, world.")  && strings same; return 0
? STRCMP("Hello, world.", "Hello, wurld.")  && strings diff; return non-0
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>STRCPY</XNAME>
			<DESCRIPTIO><![CDATA[void  _StrCpy(char FAR *dest, char FAR *src)

This example uses _StrCpy() to return a character type to FoxPro that is the concatenation of its two character type parameters.  Notice that although the memory handle of the parameter's Value structure is used as working memory to perform the concatenation, changes to this memory allocation do not affect the pass-by-value FoxPro argument.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
#define p0 (parm->p[0].val)
#define p1 (parm->p[1].val)


	if (!_SetHandSize(p0.ev_handle, p0.ev_length + p1.ev_length+1))
		_Error(182); // "Insufficient memory"
	_HLock(p0.ev_handle);
	_HLock(p1.ev_handle);

	_MemMove((char FAR *) _HandToPtr(p0.ev_handle) + p0.ev_length,
		_HandToPtr(p1.ev_handle),p1.ev_length);

	p0.ev_length+=p1.ev_length+1;
	((char *)_HandToPtr(p0.ev_handle))[p0.ev_length-1] = '\0';
	_RetChar(_HandToPtr(p0.ev_handle));
    _HUnLock(p0.ev_handle);
	_HUnLock(p1.ev_handle);
}
FoxInfo myFoxInfo[] = {
	{"STRCPY", (FPFI) Example, 2, "C,C"},
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? STRCPY("Hello", " world")	&& returns "Hello world"
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>STRLEN</XNAME>
			<DESCRIPTIO><![CDATA[int  _StrLen(char FAR *string)

This example is similar to the FoxPro function LEN(), but can't handle strings with embedded '\0'.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void NullTerminate(Value FAR *cVal)
{
	if (!_SetHandSize(cVal->ev_handle, cVal->ev_length + 1)) {
		_Error(182); // "Insufficient memory"
	}
	((char FAR *) _HandToPtr(cVal->ev_handle))[cVal->ev_length] = '\0';
}

void FAR Example(ParamBlk FAR *parm)
{
    NullTerminate(&parm->p[0].val);
    _HLock(parm->p[0].val.ev_handle);
	_RetInt(_StrLen(_HandToPtr(parm->p[0].val.ev_handle)), 10);
    _HUnLock(parm->p[0].val.ev_handle);
}
FoxInfo myFoxInfo[] = {
	{"STRLEN", (FPFI) Example, 1, "C"},
};
FoxTable _FoxTable = {
    (FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? STRLEN("Hello") && returns 5
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjgyLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODIuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>USERERRO</XNAME>
			<DESCRIPTIO><![CDATA[void  _UserError(char FAR *message)

This example calls _UserError() demonstrating that execution does not return to the API routine after a call to _UserError().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR UserErrorEx(ParamBlk FAR *parm)
{
	_UserError("This is a _UserError() example.");
	_PutStr("This should never be displayed.");
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) UserErrorEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTg3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WBOTTOM</XNAME>
			<DESCRIPTIO><![CDATA[int  _WBottom(WHANDLE wh)

This example displays the position of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\ntop    ="); putLong(_WTop(wh), 5);
	_PutStr("\nleft   ="); putLong(_WLeft(wh), 5);
	_PutStr("\nbottom ="); putLong(_WBottom(wh), 5);
	_PutStr("\nright  ="); putLong(_WRight(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WPOSITION", (FPFI) Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjUxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNTEuDQpMSU5LIDogZmF0YWwgZXJyb3IgTE5LMTEwNDogY2Fubm90IG9wZW4gZmlsZSAiLlxleGFtcGxlLmZsbCINCg0KQlVJTEQgU1VDQ0VFREVE</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WBOTTOMP</XNAME>
			<DESCRIPTIO><![CDATA[int  _WBottomP(WHANDLE wh)

This example displays the position of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\ntop    ="); putLong(_WTopP(wh), 5);
	_PutStr("\nleft   ="); putLong(_WLeftP(wh), 5);
	_PutStr("\nbottom ="); putLong(_WBottomP(wh), 5);
	_PutStr("\nright  ="); putLong(_WRightP(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WPOSITION", (FPFI)Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzYuDQpMSU5LIDogZmF0YWwgZXJyb3IgTE5LMTEwNDogY2Fubm90IG9wZW4gZmlsZSAiLlxleGFtcGxlLmZsbCINCg0KQlVJTEQgU1VDQ0VFREVE</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WCLEAR</XNAME>
			<DESCRIPTIO><![CDATA[void  _WClear(WHANDLE wh)

This example creates a window and fills it with "X"s.  When a key is pressed in response to WAIT, the window is cleared using _WClear().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WClearEx(ParamBlk FAR *parm)
{
	WHANDLE wh;
	unsigned int row, col;

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);
	_WShow(wh);

	for (row = 0; row < _WHeight(wh); row++)
	{
		for (col = 0; col < _WWidth(wh); col++)
		{
			_WPutChr(wh, 'X');
		}
		_WPutChr(wh, '\n');
	}
	_Execute("WAIT 'Press any key to clear window'");
	_WClear(wh);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) WClearEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTg2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WCLRECT</XNAME>
			<DESCRIPTIO><![CDATA[void  _WClearRect(WHANDLE wh, Rect r)

This example creates a window and fills it with "X"s.  After a key press in reponse to WAIT, a rectangular region of the window is cleared using _WClearRect().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WClearEx(ParamBlk FAR *parm)
{
	WHANDLE wh;
	unsigned int row, col;
	Rect r;

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);
	_WShow(wh);

	for (row = 0; row < _WHeight(wh); row++)
	{
		for (col = 0; col < _WWidth(wh); col++)
		{
			_WPutChr(wh, 'X');
		}
	}
	_Execute("WAIT 'Press any key to clear window rectangle'");

	r.top	 = 2;
	r.left	 = 2;
	r.bottom = 15;
	r.right  = 65;

	_WClearRect(wh, r);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) WClearEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjcxLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzEuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WCLRECTP</XNAME>
			<DESCRIPTIO><![CDATA[void  _WClearRectP(WHANDLE wh, Rect r)

This example creates a window and fills it with "X"s.  After a key press in reponse to WAIT, a rectangular region of the window is cleared using _WClearRect().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WClearEx(ParamBlk FAR *parm)
{
	WHANDLE wh;
	unsigned int row, col;
	Rect r;

	wh = _WOpen(2, 2, 20, 70, CLOSE, WINDOW_SCHEME,  0, WO_SYSTEMBORDER);
	_WShow(wh);

	for (row = 0; row < _WHeight(wh); row++)
	{
		for (col = 0; col < _WWidth(wh); col++)
		{
			_WPutChr(wh, 'X');
		}
	}
	_Execute("WAIT 'Press any key to clear window rectangle'");

	r.top	 = 20;
	r.left	 = 20;
	r.bottom = 100;
	r.right  = 300;

	_WClearRectP(wh, r);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI)WClearEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjY5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WCLOSE</XNAME>
			<DESCRIPTIO><![CDATA[void  _WClose(WHANDLE wh)

This example creates and displays a window.  After a key is pressed in response to WAIT, the window is closed with _WClose().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Ex(ParamBlk FAR *parm)
{
	WHANDLE wh;

	wh = _WOpen(2, 2, 20, 70, 0, WINDOW_SCHEME, (Scheme FAR *) 0, WO_SYSTEMBORDER);
	_WShow(wh);
    _Execute("WAIT 'Press any key to close window'");
    _WClose(wh);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Ex, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjE1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMTUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WFINDTIT</XNAME>
			<DESCRIPTIO><![CDATA[WHANDLE _WFindTitle(TEXT *title)

This example hides the window whose title is passed as an argument.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WFindTitleEx(ParamBlk FAR *parm)
{
//
//	For readability---
//
#define pTITLE ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);
	pTITLE[parm->p[0].val.ev_length] = '\0';
	wh = _WFindTitle(pTITLE);
	_HUnLock(parm->p[0].val.ev_handle);
	_WHide(wh);
}

FoxInfo myFoxInfo[] =
{
	{"WHIDE", (FPFI) WFindTitleEx, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
CREATE TABLE X (X C(10))
BROWSE NOWAIT
= WHIDE("X")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTg3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WFOOTER</XNAME>
			<DESCRIPTIO><![CDATA[void  _WFooter(WHANDLE wh, char FAR *footer)

This example creates and displays a window with both a title and a footer.  The title and footer text is retrieved using _WTitle() and _WFooter() and displayed.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;
	char FAR *buffer;

	wh = _WOpen(4, 4, 20, 70, CLOSE | WEVENT, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);

	_WSetTitle(wh, "This is a window title");
	_WSetFooter(wh, "This is a window footer");

    _WShow(wh);

	if ((buffer = _Alloca(128)) == 0)
	{
		_Error(182); // "Insufficient memory"
	}
	_WTitle(wh, buffer);

	_PutStr("\nThe window title is \"");
	_PutStr(buffer);
	_PutChr('"');

    _WFooter(wh, buffer);

	_PutStr("\nThe window footer is \"");
	_PutStr(buffer);
	_PutChr('"');
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjIwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMjAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WGETCURS</XNAME>
			<DESCRIPTIO><![CDATA[Point  _WGetCursor(WHANDLE wh)

This example creates a window and puts a diagonal of "X"s in this window.  It positions the cursor before writing each "X" using _WPosCursor() and gets that same position using _WGetCursor().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;
	Point putPos, getPos;

	wh = _WOpen(4, 4, 20, 70, 0, WINDOW_SCHEME, (Scheme FAR *) 0, WO_SYSTEMBORDER);
    _WShow(wh);

	for (putPos.v = 2; putPos.v < 14; putPos.v++)
	{
		putPos.h = putPos.v;

		_WPosCursor(wh, putPos);
		getPos = _WGetCursor(wh);
		_WPutChr(wh, 'X');

		_PutStr("\nCursor position:");
		putLong(getPos.v, 5);
		putLong(getPos.h, 5);

		_Execute("WAIT");
	}
	_WClose(wh);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTM4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMzguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WGETPORT</XNAME>
			<DESCRIPTIO><![CDATA[WHANDLE  _WGetPort(void)

This example displays the window handle returned by _WGetPort() as the current output port is changed.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{

	WHANDLE wh;
	WHANDLE oldPort;

	wh = _WOpen(2, 10, 23, 70, WEVENT | CLOSE, WINDOW_SCHEME,
		(Scheme FAR *) 0, WO_SYSTEMBORDER);
	_WShow(wh);

	_PutStr("\n1) _WGetPort() ="); putLong(_WGetPort(), 10);

    oldPort = _WSetPort(wh);
	_PutStr("\n2) _WSetPort(wh) ="); putLong(oldPort, 10);
	_PutStr("\n3) _WGetPort() ="); putLong(_WGetPort(), 10);

	oldPort = _WSetPort(oldPort);
	_PutStr("\n4) _WSetPort(oldPort) =");  putLong(oldPort, 10);

    _PutStr("\nShould be back where we started.");
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjcwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WHEIGHT</XNAME>
			<DESCRIPTIO><![CDATA[int  _WHeight(WHANDLE wh)

This example displays the height and width of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\nheight ="); putLong(_WHeight(wh), 5);
	_PutStr("\nwidth  ="); putLong(_WWidth(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WDIMEN", (FPFI) Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WHEIGHTP</XNAME>
			<DESCRIPTIO><![CDATA[int  _WHeightP(WHANDLE wh)

This example displays the height and width in pixels of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\nheight ="); putLong(_WHeightP(wh), 5);
	_PutStr("\nwidth  ="); putLong(_WWidthP(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WDIMEN", (FPFI)Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WHIDE</XNAME>
			<DESCRIPTIO><![CDATA[void  _WHide(WHANDLE wh)

This example hides the window whose title is passed as an argument.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
//
//	For readability---
//
#define pTITLE ((char FAR *) _HandToPtr(parm->p[0].val.ev_handle))

	WHANDLE wh;

	if (!_SetHandSize(parm->p[0].val.ev_handle, parm->p[0].val.ev_length + 1))
	{
		_Error(182); // "Insufficient memory"
	}
	_HLock(parm->p[0].val.ev_handle);
	pTITLE[parm->p[0].val.ev_length] = '\0';
	wh = _WFindTitle(pTITLE);
	_HUnLock(parm->p[0].val.ev_handle);
	_WHide(wh);
}

FoxInfo myFoxInfo[] =
{
	{"WHIDE", (FPFI) Example, 1, "C"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
CREATE TABLE X (X C(10))
BROWSE NOWAIT
= WHIDE("X")
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjk5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyOTkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WLEFT</XNAME>
			<DESCRIPTIO><![CDATA[int  _WLeft(WHANDLE wh)

This example displays the position of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\ntop    ="); putLong(_WTop(wh), 5);
	_PutStr("\nleft   ="); putLong(_WLeft(wh), 5);
	_PutStr("\nbottom ="); putLong(_WBottom(wh), 5);
	_PutStr("\nright  ="); putLong(_WRight(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WPOSITION", (FPFI) Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTQ0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNDQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WLEFTP</XNAME>
			<DESCRIPTIO><![CDATA[int  _WLeftP(WHANDLE wh)

This example displays the position of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\ntop    ="); putLong(_WTopP(wh), 5);
	_PutStr("\nleft   ="); putLong(_WLeftP(wh), 5);
	_PutStr("\nbottom ="); putLong(_WBottomP(wh), 5);
	_PutStr("\nright  ="); putLong(_WRightP(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WPOSITION", (FPFI)Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTIzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMjMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WMOVE</XNAME>
			<DESCRIPTIO><![CDATA[void  _WMove(WHANDLE wh, Point pt)

This example moves the topmost window diagonally ten rows down and ten columns to the right.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WMoveEx(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();
	Point newPos;

	newPos.v = _WTop(wh)  + 10;
	newPos.h = _WLeft(wh) + 10;

	_WMove(wh, newPos);
}

FoxInfo myFoxInfo[] =
{
	{"WMOVE", (FPFI) WMoveEx, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTM4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMzguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WMOVEP</XNAME>
			<DESCRIPTIO><![CDATA[void  _WMoveP(WHANDLE wh, Point pt)

This example moves the topmost window diagonally forty pixels down and forty pixels to the right.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WMovePEx(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();
	Point newPos;

	newPos.v = _WTopP(wh)  + 40;
	newPos.h = _WLeftP(wh) + 40;

	_WMoveP(wh, newPos);
}

FoxInfo myFoxInfo[] =
{
	{"WMOVEP", (FPFI)WMovePEx, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjU4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNTguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WHTOHWND</XNAME>
			<DESCRIPTIO><![CDATA[HWND _WhToHwnd(WHANDLE)

This example creates a window and then obtains the Windows HWND for the window with the callback _WhToHwnd().  Then, to verify the value returned by _WhToHwnd(), the example uses the HWND as an argument to a Windows function.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <windows.h>
#include <pro_ext.h>

void putLong(long n, int width)
{
		Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR WhToHwndEx(ParamBlk FAR *parm)
{

	RECT Rect;
	HWND hwnd;
	WHANDLE wh;

	wh = _WOpenP(10, 10, 120, 240, CLOSE,
		WINDOW_SCHEME, 0, WO_SYSTEMBORDER);

	_WShow(wh);
//
//	Get Windows window handle and use as a parameter to a Windows function
//
	hwnd = _WhToHwnd(wh);
	GetWindowRect(hwnd, &Rect); // Windows function

	_PutStr("\ntop    ="); putLong(Rect.top, 5);
	_PutStr("\nleft   ="); putLong(Rect.left, 5);
	_PutStr("\nbottom ="); putLong(Rect.bottom, 5);
	_PutStr("\nright  ="); putLong(Rect.right, 5);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI)WhToHwndEx, CALLONLOAD,  ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTA4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMDguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WONTOP</XNAME>
			<DESCRIPTIO><![CDATA[WHANDLE  _WOnTop(void)

This example displays position information of the window on top.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\ntop    ="); putLong(_WTop(wh), 5);
	_PutStr("\nleft   ="); putLong(_WLeft(wh), 5);
	_PutStr("\nbottom ="); putLong(_WBottom(wh), 5);
	_PutStr("\nright  ="); putLong(_WRight(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WPOSITION", (FPFI)Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTg3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxODcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WOPEN</XNAME>
			<DESCRIPTIO><![CDATA[WHANDLE _WOpen(int top, int left, int bottom, int right, int flag, int scheme_num, Scheme  FAR *scheme, char FAR *bord)

This example creates windows using a number of different color schemes and borders.  In particular, note the custom color scheme and custom border.  (User specified border is available in DOS only.)]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;

	char customBorder[] = "ABCDEFGHabcdefgh";
	Scheme customScheme =
	{
		(char) (BLACK_ON   | WHITE),
		(char) (RED_ON	   | BLACK	 | BLINK),
		(char) (WHITE_ON   | WHITE	 | BRIGHT),
		(char) (CYAN_ON    | BLUE	 | BRIGHT),
		(char) (GREEN_ON   | BROWN),
		(char) (BROWN_ON   | BROWN	 | BRIGHT),
		(char) (MAGENTA_ON | MAGENTA | BRIGHT),
		(char) (RED_ON	   | MAGENTA | BRIGHT | BLINK),
		(char) (BROWN_ON   | GREEN	 | BRIGHT),
		(char) (BLACK_ON   | CYAN),
		(char) (BLUE_ON    | CYAN),
	};

	_Execute("WAIT 'Press any key to see a window in WINDOW_SCHEME"
		" with WO_DOUBLEBOX border'");

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_DOUBLEBOX);

    _WShow(wh);

	_Execute("WAIT 'Press any key to see a window in ALERT_SCHEME"
		" with WO_SINGLEBOX border'");

	_WClose(wh);

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, ALERT_SCHEME, (Scheme FAR *) 0,
		WO_SINGLEBOX);

    _WShow(wh);

	_Execute("WAIT 'Press any key to see a window in WINDOW_SCHEME"
		" with WO_PANELBORDER border'");

	_WClose(wh);

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_PANELBORDER);

    _WShow(wh);

	_Execute("WAIT 'Press any key to see a window in a custom scheme"
		" with WO_SYSTEMBORDER border'");

	_WClose(wh);

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, -1, (Scheme FAR *) customScheme,
		WO_PANELBORDER);

    _WShow(wh);

	_Execute("WAIT 'Press any key to see a window in WINDOW_SCHEME"
		" with a custom border (DOS only)'");

	_WClose(wh);

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0,
		customBorder);

    _WShow(wh);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WPOSCUR</XNAME>
			<DESCRIPTIO><![CDATA[void  _WPosCursor(WHANDLE wh, Point pt)

This example creates a window and puts a diagonal of "X"s in this window.  It positions the cursor before writing each "X" using _WPosCursor() and gets that same position using _WGetCursor().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;
	Point putPos, getPos;

	wh = _WOpen(4, 4, 20, 70, 0, WINDOW_SCHEME, (Scheme FAR *) 0, WO_SYSTEMBORDER);
    _WShow(wh);

	for (putPos.v = 2; putPos.v < 14; putPos.v++)
	{
		putPos.h = putPos.v;

		_WPosCursor(wh, putPos);
		_WPutChr(wh, 'X');

		getPos = _WGetCursor(wh);

		_PutStr("\nCursor position:");
		putLong(getPos.v, 5);
		putLong(getPos.h, 5);

		_Execute("WAIT");
	}
	_WClose(wh);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTA2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMDYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WPOSCURP</XNAME>
			<DESCRIPTIO><![CDATA[void  _WPosCursorP(WHANDLE wh, Point pt)

This example creates a window and puts a diagonal of "X"s in this window.  It positions the cursor before writing each "X" using _WPosCursorP() and gets that same position using _WGetCursorP().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;
	Point putPos, getPos;

	wh = _WOpen(4, 4, 20, 70, 0, WINDOW_SCHEME, 0, WO_SYSTEMBORDER);
    _WShow(wh);

	for (putPos.v = 10; putPos.v < 100; putPos.v += 10)
	{
		putPos.h = putPos.v;

		_WPosCursorP(wh, putPos);
		_WPutChr(wh, 'X');

		getPos = _WGetCursorP(wh);

		_PutStr("\nCursor position:");
		putLong(getPos.v, 5);
		putLong(getPos.h, 5);

		_Execute("WAIT");
	}
	_WClose(wh);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI)Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjYwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WPUTCHR</XNAME>
			<DESCRIPTIO><![CDATA[void  _WPutChr(WHANDLE wh, int char)

This example uses _WPutChr() to display all 8-bit values to a window it creates.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	int i;
	WHANDLE wh;

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);

	_WShow(wh);

	for (i = 0; i < 256; i++)
		_WPutChr(wh, i);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjgwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WPUTSTR</XNAME>
			<DESCRIPTIO><![CDATA[void  _WPutStr(WHANDLE wh, char FAR *str)

This example uses _WPutStr() to display a string containing all 8-bit values (except '\0') to a window it creates.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	int i;
	WHANDLE wh;
	char String[256];

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);

	_WShow(wh);

	for (i = 0; i < 255; i++)
		String[i] = i + 1;

	String[255] = '\0';

    _WPutStr(wh, String);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjg1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WRIGHT</XNAME>
			<DESCRIPTIO><![CDATA[int  _WRight(WHANDLE wh)

This example displays the position of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\ntop    ="); putLong(_WTop(wh), 5);
	_PutStr("\nleft   ="); putLong(_WLeft(wh), 5);
	_PutStr("\nbottom ="); putLong(_WBottom(wh), 5);
	_PutStr("\nright  ="); putLong(_WRight(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WPOSITION", (FPFI) Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjIwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMjAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WRIGHTP</XNAME>
			<DESCRIPTIO><![CDATA[int  _WRightP(WHANDLE wh)

This example displays the position of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\ntop    ="); putLong(_WTopP(wh), 5);
	_PutStr("\nleft   ="); putLong(_WLeftP(wh), 5);
	_PutStr("\nbottom ="); putLong(_WBottomP(wh), 5);
	_PutStr("\nright  ="); putLong(_WRightP(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WPOSITION", (FPFI)Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDQwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwNDAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSCROLL</XNAME>
			<DESCRIPTIO><![CDATA[void  _WScroll(WHANDLE wh, Rect r, int dv, int dh)

This example opens a window and draws a rectangle of "X"s.  This rectangle is also the scroll rectangle.  First, it is scrolled up two positions and to the left two positions.  Next, it scrolled down by four positions and to the right four positions.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WScrollEx(ParamBlk FAR *parm)
{
	WHANDLE wh;
	Point pos;
	Rect rect;

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME,
		(Scheme FAR *) 0, WO_SYSTEMBORDER);

    _WShow(wh);

	rect.top	= 6;
	rect.left	= 6;
	rect.bottom = 12;
	rect.right	= 12;

	for (pos.v = rect.top; pos.v < rect.bottom; pos.v++)
	{
		for (pos.h = rect.left; pos.h < rect.right; pos.h++)
		{
			_WPosCursor(wh, pos);
            _WPutChr(wh, 'X');
		}
	}
	_Execute("WAIT 'Press any key to _WScroll(wh, rect, -2, -2)'");
	_WScroll(wh, rect, -2, -2);
	_Execute("WAIT 'Press any key to _WScroll(wh, rect, +4, +4)'");
	_WScroll(wh, rect, +4, +4);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) WScrollEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTc1Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNzUuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSCROLLP</XNAME>
			<DESCRIPTIO><![CDATA[void  _WScrollP(WHANDLE wh, Rect r, int dv, int dh)

This example opens a window and draws a rectangle of "X"s.  This rectangle is also the scroll rectangle.  First, it is scrolled up and left.  Next, it scrolled down and right.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WScrollEx(ParamBlk FAR *parm)
{
	WHANDLE wh;
	Point pos;
	Rect rect;

	wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME,
		0, WO_SYSTEMBORDER);

    _WShow(wh);

	rect.top	= 6;
	rect.left	= 6;
	rect.bottom = 12;
	rect.right	= 12;

	for (pos.v = rect.top; pos.v < rect.bottom; pos.v++)
	{
		for (pos.h = rect.left; pos.h < rect.right; pos.h++)
		{
			_WPosCursor(wh, pos);
            _WPutChr(wh, 'X');
		}
	}
	_Execute("WAIT 'Press any key to _WScroll(wh, rect, -2, -2)'");
	_WScroll(wh, rect, -2, -2);
	_Execute("WAIT 'Press any key to _WScroll(wh, rect, +4, +4)'");
	_WScroll(wh, rect, +4, +4);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI)WScrollEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjk3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyOTcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSELECT</XNAME>
			<DESCRIPTIO><![CDATA[void  _WSelect(WHANDLE wh)

This example creates five overlapping windows.  The windows are _WSelect()-ed starting with the first created.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WSelectEx(ParamBlk FAR *parm)
{
	WHANDLE wh[5];
	int i;

	for (i = 0; i < 5; i++)
	{
		wh[i] = _WOpen(4 + 2*i, 4 + 2*i, 12 + 2*i, 40 + 2*i,
			WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0, WO_SYSTEMBORDER);

		_WShow(wh[i]);
	}
	for (i = 0; i < 5; i++)
	{
		_Execute("WAIT 'Press key to _WSelect() next window'");
        _WSelect(wh[i]);
	}
}


FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) WSelectEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjM2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSENDBEH</XNAME>
			<DESCRIPTIO><![CDATA[void  _WSendBehind(WHANDLE wh)

This example creates five overlapping windows.  _WSendBehind() is called on each window starting with the last created.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WSendBehindEx(ParamBlk FAR *parm)
{
	WHANDLE wh[5];
	int i;

	for (i = 0; i < 5; i++)
	{
		wh[i] = _WOpen(4 + 2*i, 4 + 2*i, 12 + 2*i, 40 + 2*i,
			WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0, WO_SYSTEMBORDER);

		_WShow(wh[i]);
	}
	for (i = 4; i >= 0; i--)
	{
		_Execute("WAIT 'Press key to _WSendBehind() next window'");
		_WSendBehind(wh[i]);
	}
}


FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) WSendBehindEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjE5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyMTkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSETFOOT</XNAME>
			<DESCRIPTIO><![CDATA[void  _WSetFooter(WHANDLE wh, char FAR *footer)

This example creates a window and sets its title text with _WSetTitle() and its footer text with _WSetFooter().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;
	char FAR *buffer;

	wh = _WOpen(4, 4, 20, 70, CLOSE | WEVENT, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);

	_WSetTitle(wh, "This is a window title");
	_WSetFooter(wh, "This is a window footer");

    _WShow(wh);

	if ((buffer = _Alloca(128)) == 0)
	{
		_Error(182); // "Insufficient memory"
	}
	_WTitle(wh, buffer);

	_PutStr("\nThe window title is \"");
	_PutStr(buffer);
	_PutChr('"');

    _WFooter(wh, buffer);

	_PutStr("\nThe window footer is \"");
	_PutStr(buffer);
	_PutChr('"');
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTA3Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMDcuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSETPORT</XNAME>
			<DESCRIPTIO><![CDATA[WHANDLE  _WSetPort(WHANDLE wh)

This example creates a window and makes this the output port.  It writes some text to this window before switching back to the original output port.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{

	WHANDLE wh;
	WHANDLE oldPort;

	wh = _WOpen(2, 10, 23, 70, WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);

	_WShow(wh);

	_PutStr("\n1) _WGetPort() ="); putLong(_WGetPort(), 10);

    oldPort = _WSetPort(wh);
	_PutStr("\n2) _WSetPort(wh) ="); putLong(oldPort, 10);

	_PutStr("\n3) _WGetPort() ="); putLong(_WGetPort(), 10);

	oldPort = _WSetPort(oldPort);
	_PutStr("\n4) _WSetPort(oldPort) =");  putLong(oldPort, 10);

    _PutStr("\nShould be back where we started.");
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjYyLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjIuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSETTITL</XNAME>
			<DESCRIPTIO><![CDATA[void  _WSetTitle(WHANDLE wh, char FAR *title)

This example creates a window and sets its title text with _WSetTitle() and its footer text with _WSetFooter().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;
	char FAR *buffer;

	wh = _WOpen(4, 4, 20, 70, CLOSE | WEVENT, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);

	_WSetTitle(wh, "This is a window title");
	_WSetFooter(wh, "This is a window footer");

    _WShow(wh);

	if ((buffer = _Alloca(128)) == 0)
	{
		_Error(182); // "Insufficient memory"
	}
	_WTitle(wh, buffer);

	_PutStr("\nThe window title is \"");
	_PutStr(buffer);
	_PutChr('"');

    _WFooter(wh, buffer);

	_PutStr("\nThe window footer is \"");
	_PutStr(buffer);
	_PutChr('"');
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTQ5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNDkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSHOW</XNAME>
			<DESCRIPTIO><![CDATA[void  _WShow(WHANDLE wh)

This example contains two API routines.  WOPEN() opens a window but does not call _WShow(), showing that the window is not displayed until _WShow() is called.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WOpen(ParamBlk FAR *parm)
{
	_RetInt(_WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME,
		(Scheme FAR *) 0, WO_SYSTEMBORDER), 10);
}

void FAR WShow(ParamBlk FAR *parm)
{
	_WShow(parm->p[0].val.ev_long);
}

FoxInfo myFoxInfo[] =
{
	{"WOPEN", (FPFI) WOpen, 0, ""},
	{"WSHOW", (FPFI) WShow, 1, "I"},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
wh = WOPEN()
= WSHOW(wh)
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjQ5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNDkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSIZE</XNAME>
			<DESCRIPTIO><![CDATA[void  _WSize(WHANDLE wh, Point pt)

This example creates a window and grows its width first, then its height.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WSizeEx(ParamBlk FAR *parm)
{
	WHANDLE wh;
	Point dim;

	wh = _WOpen(2, 2, 10, 10, CLOSE | WEVENT, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);

    _WShow(wh);

	dim.v = 8;
//
//	Grow in width
//
	for (dim.h = 8; dim.h < 60; dim.h += 4)
	{
		_WSize(wh, dim);
		_Execute("WAIT");
	}
//
//	Grow in height
//
	for (dim.v = 8; dim.v < 20; dim.v += 2)
	{
		_WSize(wh, dim);
		_Execute("WAIT");
	}
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) WSizeEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjY4Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjguDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WSIZEP</XNAME>
			<DESCRIPTIO><![CDATA[void  _WSizeP(WHANDLE wh, Point pt)

This example creates a window and grows its width first, then its height.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR WSizeEx(ParamBlk FAR *parm)
{
	WHANDLE wh;
	Point dim;

	wh = _WOpenP(6, 6, 20, 20, CLOSE | WEVENT, WINDOW_SCHEME, 0,
		WO_SYSTEMBORDER);

    _WShow(wh);

	dim.v = 14;
//
//	Grow in width
//
	for (dim.h = 14; dim.h < 480; dim.h += 40)
	{
		_WSizeP(wh, dim);
		_Execute("WAIT");
	}
//
//	Grow in height
//
	for (dim.v = 14; dim.v < 240; dim.v += 40)
	{
		_WSizeP(wh, dim);
		_Execute("WAIT");
	}
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI)WSizeEx, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDkzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwOTMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WTITLE</XNAME>
			<DESCRIPTIO><![CDATA[void  _WTitle(WHANDLE wh, char FAR *title)

This example creates and displays a window with both a title and a footer.  The title and footer text is retrieved using _WTitle() and _WFooter() and displayed.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;
	char FAR *buffer;

	wh = _WOpen(4, 4, 20, 70, CLOSE | WEVENT, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);

	_WSetTitle(wh, "This is a window title");
	_WSetFooter(wh, "This is a window footer");

    _WShow(wh);

	if ((buffer = _Alloca(128)) == 0)
	{
		_Error(182); // "Insufficient memory"
	}
	_WTitle(wh, buffer);

	_PutStr("\nThe window title is \"");
	_PutStr(buffer);
	_PutChr('"');

    _WFooter(wh, buffer);

	_PutStr("\nThe window footer is \"");
	_PutStr(buffer);
	_PutChr('"');
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjYzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WTOP</XNAME>
			<DESCRIPTIO><![CDATA[int  _WTop(WHANDLE wh)

This example displays the position of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\ntop    ="); putLong(_WTop(wh), 5);
	_PutStr("\nleft   ="); putLong(_WLeft(wh), 5);
	_PutStr("\nbottom ="); putLong(_WBottom(wh), 5);
	_PutStr("\nright  ="); putLong(_WRight(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WPOSITION", (FPFI) Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMDc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAwNzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WTOPP</XNAME>
			<DESCRIPTIO><![CDATA[int  _WTopP(WHANDLE wh)

This example displays the position of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\ntop    ="); putLong(_WTopP(wh), 5);
	_PutStr("\nleft   ="); putLong(_WLeftP(wh), 5);
	_PutStr("\nbottom ="); putLong(_WBottomP(wh), 5);
	_PutStr("\nright  ="); putLong(_WRightP(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WPOSITION", (FPFI)Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WWIDTH</XNAME>
			<DESCRIPTIO><![CDATA[int  _WWidth(WHANDLE wh)

This example displays the height and width of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\nheight ="); putLong(_WHeight(wh), 5);
	_PutStr("\nwidth  ="); putLong(_WWidth(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WDIMEN", (FPFI) Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTE5Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxMTkuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WWIDTHP</XNAME>
			<DESCRIPTIO><![CDATA[int  _WWidthP(WHANDLE wh)

This example displays the height and width in pixels of the topmost window.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
    WHANDLE wh = _WOnTop();

	_PutStr("\nheight ="); putLong(_WHeightP(wh), 5);
	_PutStr("\nwidth  ="); putLong(_WWidthP(wh), 5);
}

FoxInfo myFoxInfo[] =
{
	{"WDIMEN", (FPFI)Example, 0, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjY0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNjQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WZOOM</XNAME>
			<DESCRIPTIO><![CDATA[void  _WZoom(WHANDLE wh, int newstate)

This example creates and displays a window.  It then calls _WZoom() for this window with each of its parameters, WZ_MINIMIZE, WZ_NORMAL, and WZ_MAXIMIZE.]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;


    wh = _WOpen(2, 2, 20, 70, WEVENT | CLOSE, WINDOW_SCHEME, (Scheme FAR *) 0,
		WO_SYSTEMBORDER);

	_WShow(wh);

	_Execute("WAIT 'Press any key to minimize window'");
	_WZoom(wh, WZ_MINIMIZED);

	_Execute("WAIT 'Press any key to normalize window'");
	_WZoom(wh, WZ_NORMAL);

	_Execute("WAIT 'Press any key to maximize window'");
	_WZoom(wh, WZ_MAXIMIZED);

	_Execute("WAIT 'Press any key to normalize window'");
	_WZoom(wh, WZ_NORMAL);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI) Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjc0Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNzQuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WGETCURP</XNAME>
			<DESCRIPTIO><![CDATA[Point  _WGetCursorP(WHANDLE wh)

This example creates a window and puts a diagonal of "X"s in this window.  It positions the cursor before writing each "X" using _WPosCursorP() and gets that same position using _WGetCursorP().]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void putLong(long n, int width)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = width;

	_PutValue(&val);
}

void FAR Example(ParamBlk FAR *parm)
{
	WHANDLE wh;
	Point putPos, getPos;

	wh = _WOpen(4, 4, 20, 70, 0, WINDOW_SCHEME, 0, WO_SYSTEMBORDER);
    _WShow(wh);

	for (putPos.v = 10; putPos.v < 100; putPos.v += 10)
	{
		putPos.h = putPos.v;

		_WPosCursorP(wh, putPos);
		_WPutChr(wh, 'X');

		getPos = _WGetCursorP(wh);

		_PutStr("\nCursor position:");
		putLong(getPos.v, 5);
		putLong(getPos.h, 5);

		_Execute("WAIT");
	}
	_WClose(wh);
}

FoxInfo myFoxInfo[] =
{
	{"ONLOAD", (FPFI)Example, CALLONLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjU2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNTYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>DBAPPRE</XNAME>
			<DESCRIPTIO><![CDATA[int _DBAppendRecords(int workarea, int numrecs, char FAR *buffer)

This example creates a test DBF with two fields.  Two records are appended to this DBF by calling the API routine which in turn calls _DBAppendRecords().  Notice that the append buffer must include a delete byte for each record.
]]></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void NullTerminate(Value FAR *cVal)
{
	if (!_SetHandSize(cVal->ev_handle, cVal->ev_length + 1))
		_Error(182); // "Insufficient memory"
	((char FAR *) _HandToPtr(cVal->ev_handle))[cVal->ev_length] = '\0';
}
void FAR xDBAppendRecords(ParamBlk FAR *parm)
{
	int workarea = parm->p[0].val.ev_long;
	int nRecs    = parm->p[1].val.ev_long;
    char FAR *buffer;
    int retCode;

    _HLock(parm->p[2].val.ev_handle);
	buffer = _HandToPtr(parm->p[2].val.ev_handle);
	retCode = _DBAppendRecords(workarea, (unsigned short) nRecs, buffer);
	_HUnLock(parm->p[2].val.ev_handle);
	if (retCode < 0)
		_Error(-retCode);
}
FoxInfo myFoxInfo[] =
{
	{"DBAPPRECS", (FPFI) xDBAppendRecords, 3, "I,I,C"},
};
FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
CREATE TABLE Test (City C(20), State C(2))
APPBUFFER = " PERRYSBURG          OH"   && include delete byte = ASCII space
APPBUFFER = APPBUFFER + " REDMOND             WA"
= DBAPPRECS(-1, 2, APPBUFFER)
LIST
USE]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjgzLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyODMuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>WMAINWIN</XNAME>
			<DESCRIPTIO></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

void FAR example(ParamBlk FAR *parm)
{
	WHANDLE wh = _WMainWindow();
	_WPutStr(wh, "\nThis is the outermost FoxPro window.");
}
FoxInfo myFoxInfo[] =
{
	{"EXWMAIN", (FPFI)example, 0, ""},
};
FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};

]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
= EXWMAIN()
]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.F.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMjQwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAyNDAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>GETITEMS</XNAME>
			<DESCRIPTIO></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>

MENUID SysMenuId, retMenuId;
MENUID PopupId;
ITEMID PadId;

void putLong(long n)
{
	Value val;

	val.ev_type = 'I';
	val.ev_long = n;
	val.ev_width = 10;

	_PutValue(&val);
}

FAR onSelection(long menuId, long itemId)
{
	_PutStr("\nitemId = "); putLong(itemId);
	return 0;
}

void FAR StartUp()
{
		ITEMID Bar1Id;
		ITEMID Bar2Id;

        int Error;
//
//	Add new pad to SYSMENU.
//
    SysMenuId = _MenuId(_SYSMENU);
    PadId = _GetNewItemId(SysMenuId);

	if (_NewItem(SysMenuId, PadId, _LASTITEM, "\\<Added pad"))
    {
        _Error(623); /* "Menu item cannot be defined." */
    }
//
//	Define popup menu.
//
    PopupId = _GetNewMenuId();

    if (Error = _NewMenu(MPOPUP, PopupId))
    {
        _Error(-Error);
    }
	Bar1Id = _GetNewItemId(PopupId);
//
//		WARNING: Call _NewItem() before another _GetNewItemId().
//
	if (_NewItem(PopupId, Bar1Id, _LASTITEM, "\\<1st item"))
    {
        _Error(623); /* "Menu item cannot be defined." */
    }
	Bar2Id = _GetNewItemId(PopupId);

	if (_NewItem(PopupId, Bar2Id, _LASTITEM, "\\<2nd item"))
    {
        _Error(623); /* "Menu item cannot be defined." */
    }
//
//	Attach popup to pad.
//
    _SetItemSubMenu(SysMenuId, PadId, PopupId);

    _PutStr("\nSubMenu Id = "); putLong(PopupId);

//
//  Set up selection action.
//
	retMenuId = _GetItemSubMenu(SysMenuId,PadId);
	_PutStr("\nThis is the return value from  _GetItemSubMenu.  retMenuId = "); putLong(retMenuId);

	_OnSelection(PopupId, -1, onSelection);
}

void FAR ShutDown()
{
    _DisposeItem(SysMenuId, PadId);
    _DisposeMenu(PopupId);
}

FoxInfo myFoxInfo[] =
{
	{"STARTUP",     (FPFI) StartUp,    CALLONLOAD,   ""},
	{"SHUTDOWN",    (FPFI) ShutDown,   CALLONUNLOAD, ""},
};

FoxTable _FoxTable =
{
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTc2Lg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxNzYuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

		<RECORD>
			<XNAME>RETCURR</XNAME>
			<DESCRIPTIO></DESCRIPTIO>
			<C_CODE><![CDATA[#include <pro_ext.h>
#include <math.h>

void FAR retcurr(ParamBlk FAR *parm)
{
	CCY money;

	money.HighPart = (long) (parm->p[0].val.ev_real*10000 / pow(2,32));
	
	money.LowPart = (unsigned long) ((parm->p[0].val.ev_real - (double) (money.HighPart * pow(2,32)/10000.0)) *10000);
	
	_RetCurrency(money,25);
}

FoxInfo myFoxInfo[] = {
	{"XNTOM", (FPFI) retcurr, 1, "N"}
};
FoxTable _FoxTable = {
	(FoxTable FAR *) 0, sizeof(myFoxInfo)/sizeof(FoxInfo), myFoxInfo
};
]]></C_CODE>
			<X_CODE><![CDATA[SET LIBRARY TO example
? xntom(100.1)]]></X_CODE>
			<WIN>.T.</WIN>
			<DOS>.T.</DOS>
			<BUILD>U2V0dGluZyBlbnZpcm9ubWVudCBmb3IgdXNpbmcgTWljcm9zb2Z0IFZpc3VhbCBDKysgdG9vbHMuDQoJY2wuZXhlIEBkOlx0ZW1wXG5tYTAwMTkwLg0KZXhhbXBsZS5jDQoJbGluay5leGUgQGQ6XHRlbXBcbm1iMDAxOTAuDQogICBDcmVhdGluZyBsaWJyYXJ5IC5cZXhhbXBsZS5saWIgYW5kIG9iamVjdCAuXGV4YW1wbGUuZXhwDQoNCkJVSUxEIFNVQ0NFRURFRA==</BUILD>
		</RECORD>

	</RECORDS>


</TABLE>

