*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="wmhandler.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS filedetect AS wmbase OF "wmhandler.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "wmhandler.h"
	*<DefinedPropArrayMethod>
		*p: dwshnotify
	*</DefinedPropArrayMethod>

	Name = "filedetect"
	
	PROCEDURE Destroy
		THIS.ReLeaseEvent()
		
		THIS.RemoveDLL("SHGetSpecialFolderLocation")
		THIS.RemoveDLL("SHChangeNotifyRegister")
		THIS.RemoveDLL("SHChangeNotifyDeregister")
		THIS.RemoveDLL("SHILCreateFromPath")
		THIS.RemoveDLL("SHGetPathFromIDList")
		THIS.RemoveDLL("CoTaskMemFree")
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE handlewinmsg
		LPARAMETERS hWnd as Integer, Msg as Integer, wParam as Integer, lParam as Integer
		
		ACTIVATE SCREEN
		LOCAL nRetvalue,lcStr,lcStr2,pidl1,pidl2,lcPath,lcPath2
		
		STORE "" TO lcStr, lcStr2
		STORE SPACE(270) TO lcPath, lcPath2
		pidl1=CTOBIN(SYS(2600,wParam,4),"4rs")
		pidl2=CTOBIN(SYS(2600,wParam+4,4),"4rs")
		SHGetPathFromIDList(pidl1,@lcPath)
		lcPath=LEFT(lcPath,AT(CHR(0),lcPath)-1)
		SHGetPathFromIDList(pidl2,@lcPath2)
		lcPath2=LEFT(lcPath2,AT(CHR(0),lcPath2)-1)
		
		IF EMPTY(ALLTRIM(lcPath2))
			lcPath = "Path: "+lcPath
		ELSE
			lcPath = "Original Path: "+lcPath+CHR(13)+CHR(10)+CHR(9)+;
				"New Path: "+lcPath2
		ENDIF
		
		DO case
		CASE lParam=SHCNE_UPDATEDIR
			lcStr = "Updated file/directory"
		CASE lParam=SHCNE_CREATE OR lParam=SHCNE_MKDIR               
			lcStr = "Created file/directory"
		CASE lParam=SHCNE_DELETE OR lParam=SHCNE_RMDIR
			lcStr = "Deleted file/directory"
		CASE lParam=SHCNE_RENAMEFOLDER OR lParam=SHCNE_RENAMEITEM
			lcStr = "Rename file/directory"
		CASE lParam=SHCNE_ATTRIBUTES  OR lParam=SHCNE_UPDATEITEM 
			lcStr = "Updated file/directory attributes"
		OTHERWISE
			lcStr = "Other Shell event occurred."
		ENDCASE
		
		TEXT TO lcStr2 TEXT NOSHOW
		<<lcStr>>:
			<<lcPath>>
		
		ENDTEXT
		
		
		IF VARTYPE(THIS.oHandler)="O" AND PEMSTATUS(THIS.oHandler,"HandleWinMsg",5)
			THIS.oHandler.HandleWinMsg(lcStr2)
		ENDIF
		
		nRetvalue=CallWindowProc(this.nOldProc, hWnd, msg, wParam, lParam)
		RETURN nRetvalue
		
	ENDPROC

	PROCEDURE init2
		DECLARE integer SHChangeNotifyRegister IN shell32 ;
			integer hWnd, ;
			integer fSources, ;
			integer fEvents, ;
			integer wMsg,;
			integer cEntries, ;
			string @ SEntry 
		
		DECLARE integer SHChangeNotifyDeregister IN shell32 integer
		
		DECLARE integer SHGetSpecialFolderLocation  IN shell32 ;
			integer hWnd,;
			integer nFolder,;
			string @ pItemList
		
		DECLARE integer SHGetPathFromIDList IN shell32 ;
			integer nItemList,;
			string @cPath
		
		DECLARE integer SHILCreateFromPath IN shell32 ;
			string szPath,;
			integer @ pidl  ,;
			integer @ rgflnOut 
		
		DECLARE integer CoTaskMemFree IN ole32 ;
			integer dwAddr
		
	ENDPROC

	PROCEDURE loadevent
		LOCAL rgflnOut, szPath, pidl, nRecursive,nSources,lcSEntry
		
		rgflnOut=0
		szPath=SYS(5)+CURDIR()
		pidl=0
		nRecursive=1
		nSources=0
		SHILCreateFromPath(STRCONV(szPath+CHR(0),5),@pidl,@rgflnOut)
		
		IF MESSAGEBOX([Would you like to capture file/folder shell events for your Visual FoxPro default directory <"Yes"> or all locations <"No">?],36)=6
			lcSEntry = BINTOC(pidl,"4rs")+BINTOC(nRecursive,"4rs")	
			nSources= 0x1000 * nRecursive + 3
		ELSE
			lcSEntry = REPLICATE(CHR(0), 8)
			nSources = SHCNE_DISKEVENTS
		ENDIF
		
		THIS.dwShNotify = SHChangeNotifyRegister(_vfp.hWnd, nSources,;
		  SHCNE_DISKEVENTS , ;
		  WM_USER_SHNOTIFY,1, ;
		  @lcSEntry)
		
		CoTaskMemFree(pidl)
		
		BINDEVENT(_VFP.hWnd, WM_USER_SHNOTIFY, THIS, "handlewinmsg")
		
		THIS.Eventloaded = .T.
	ENDPROC

	PROCEDURE releaseevent
		IF THIS.Eventloaded
			UNBINDEVENT(_VFP.hWnd, WM_USER_SHNOTIFY)
			IF THIS.dwShNotify != 0
				SHChangeNotifyDeregister(THIS.dwShNotify)
			ENDIF 
			THIS.Eventloaded = .F.
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS foxactivate AS wmbase OF "wmhandler.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "wmhandler.h"
	Name = "foxactivate"
	
	PROCEDURE Destroy
		THIS.RemoveDLL("Beep")
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE handlewinmsg
		LPARAMETERS hWnd as Integer, Msg as Integer, wParam as Integer, lParam as Integer
		nRetvalue=0
		IF Msg = WM_ACTIVATE && App Switching
			LOCAL loword, hiword, lcStr
		
			loword=BITAND(wparam,0xffff)
			hiword=BITAND(wparam,0xffff0000)/2^16
		
			IF wparam=WA_INACTIVE OR hiword!=0
				Beep(800,100)	&& inactive
				Beep(500,100)
			ELSE
				Beep(500,100)	&& active
				Beep(800,100)
			ENDIF
			
			lcStr = ICASE(WParam=WA_INACTIVE,'Inactive',WParam=WA_ACTIVE,;
				'Active',WParam=WA_CLICKACTIVE,'Click Active','Other')
		
			IF VARTYPE(THIS.oHandler)="O" AND PEMSTATUS(THIS.oHandler,"HandleWinMsg",5)
				THIS.oHandler.HandleWinMsg(lcStr)
			ENDIF
			
			nRetvalue = CallWindowProc(THIS.noldproc,hWnd,msg,wParam,lParam)
		ENDIF
		RETURN nRetvalue
		
	ENDPROC

	PROCEDURE init2
		DECLARE integer Beep IN WIN32API ;
			integer nFreq,;
			integer nDuration
		
	ENDPROC

	PROCEDURE loadevent
		BINDEVENT(_VFP.hWnd, WM_ACTIVATE, THIS, "handlewinmsg" )
		THIS.Eventloaded = .T.
	ENDPROC

	PROCEDURE releaseevent
		IF THIS.Eventloaded = .T.
			UNBINDEVENT(_VFP.hWnd, WM_ACTIVATE)
			THIS.eventloaded = .F.
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS foxwindows AS wmbase OF "wmhandler.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "wmhandler.h"
	*<DefinedPropArrayMethod>
		*m: addwindow
		*m: findawindow
		*m: getwindowtitle
		*m: removewindow
		*m: searchchildwindows
		*p: otview
	*</DefinedPropArrayMethod>

	Name = "foxwindows"
	otview = .F.
	
	PROCEDURE addwindow
		LPARAMETERS hWnd
		
		LOCAL i, lFound, lcTitle 
		
		IF hWnd=_vfp.hWnd
			RETURN
		ENDIF
		
		lcTitle = ALLTRIM(THIS.GetWindowTitle(hWnd))
		IF EMPTY(lcTitle) OR INLIST(lcTitle,"Debugger","Watch","Locals","Trace","Call Stack","Debug Output")
			RETURN
		ENDIF
		
		FOR i = 1 TO THIS.otView.nodes.count
			IF THIS.otView.Nodes(i).Text == lcTitle
				lFound=.T.
				RETURN
			ENDIF
		ENDFOR
		
		THIS.otView.Nodes.add(,,TRANSFORM(hwnd,"@0x"), lcTitle)
		
		BINDEVENT(hWnd, WM_DESTROY,this,"handlewinmsg",4)
		BINDEVENT(hWnd, WM_SETTEXT,this,"handlewinmsg",4)
		BINDEVENT(hWnd, WM_SETFOCUS,this,"handlewinmsg",4)
		BINDEVENT(hWnd, WM_WINDOWPOSCHANGED,this,"handlewinmsg",4)
		
	ENDPROC

	PROCEDURE Destroy
		THIS.RemoveDLL("DefWindowProc")
		THIS.RemoveDLL("FindWindowEx")
		THIS.RemoveDLL("GetWindowInfo")
		THIS.RemoveDLL("GetWindowText")
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE findawindow
		LPARAMETERS hWnd
		LOCAL i
		FOR i = 1 TO THIS.otView.nodes.count
			IF THIS.otView.Nodes(i).key = TRANSFORM(hwnd,"@0x")
				RETURN i
			ENDIF 
		ENDFOR 
		RETURN 0	&& not found
	ENDPROC

	PROCEDURE getwindowtitle
		LPARAMETERS hWnd
		LOCAL cStr
		cstr=SPACE(200)
		GetWindowText(hWnd,@cstr,LEN(cstr))
		IF AT(CHR(0),cstr)>0
			cstr=LEFT(cstr,AT(CHR(0),cstr)-1)
		ENDIF 
		RETURN cstr
		
		
	ENDPROC

	PROCEDURE handlewinmsg
		LPARAMETERS hWnd as Integer, Msg as Integer, wParam as Integer, lParam as Integer
		
		LOCAL nRetvalue, hwndInsAfter, i, dwStyle
		nRetvalue=0
		
		DO case
		CASE msg=WM_WINDOWPOSCHANGED
			nRetvalue= CallWindowProc(THIS.noldproc, hWnd, msg, wParam, lParam)
			hwndInsAfter=CTOBIN(SYS(2600,lParam+(4*1),4),"4rs")
		
			i=THIS.FindAWindow(hWnd)
			IF i >0
				THIS.otView.nodes(i).Selected=1
			ENDIF 
		
		CASE msg=WM_SETFOCUS
			nRetvalue= CallWindowProc(THIS.noldproc, hWnd, msg, wParam, lParam)
			
		CASE msg=WM_SETTEXT
			i=this.FindAWindow(hWnd)
			nRetvalue= CallWindowProc(THIS.noldproc, hWnd, msg, wParam, lParam)
			THIS.otView.nodes(i).text=THIS.GetWindowTitle(hWnd)
		
		CASE msg=WM_SHOWWINDOW
			IF wParam!=0
				THIS.AddWindow(hWnd)
			ENDIF
			UNBINDEVENTS(hWnd,msg)	
			nRetvalue= CallWindowProc(THIS.noldproc, hWnd, msg, wParam, lParam)
		
		CASE msg=WM_CREATE
			nRetvalue= CallWindowProc(THIS.noldproc, hWnd, msg, wParam, lParam)
			dwStyle=CTOBIN(SYS(2600,lParam+(4*8),4),"4rs")
			IF BITAND(dwStyle ,WS_BORDER) = WS_BORDER
				BINDEVENT(hWnd, WM_SHOWWINDOW, THIS, "handlewinmsg", 4)
			ENDIF
			nRetvalue=0
			
		CASE msg=WM_DESTROY
			THIS.RemoveWindow(hWnd)
			nRetvalue= CallWindowProc(THIS.noldproc, hWnd, msg, wParam, lParam)
		
		ENDCASE
		
		RETURN nRetvalue
		
	ENDPROC

	PROCEDURE init2
		DECLARE integer DefWindowProc IN WIN32API ;
			integer hWnd,;
			integer Msg,;
			integer wParam,;
			integer lParam
		DECLARE integer FindWindowEx IN WIN32API ;
			integer hWndParent,;
			integer hwndChildAfter, ;
			string lpszClass,;
			string lpszWindow
		DECLARE integer GetWindowInfo IN WIN32API ;
			integer hWnd,;
			string @ pwindowinfo
		DECLARE integer GetWindowText IN WIN32API ;
			integer hWnd, string @szText, integer nLen
		
	ENDPROC

	PROCEDURE loadevent
		IF  TYPE("THIS.oHandler.cntEvent.oleTreeView")="O"
			THIS.otView = THIS.oHandler.cntEvent.oleTreeView
			BINDEVENT(THIS.oHandler,"QueryUnload",this,"ReleaseEvent")
		ELSE
			PUBLIC loForm
			loForm = CREATEOBJECT("form")
			WITH loForm
				.Dockable = 1
				.Caption = "Fox Windows"	
				.AddObject("oleTreeView","olecontrol","mscomctllib.treectrl.2")
			ENDWITH	
			WITH loForm.oleTreeView
				.Width = loForm.Width
				.Height = loForm.Height
				.Anchor = 15
				.Visible = .T.
			ENDWITH
			THIS.otView = loForm.oleTreeView
			BINDEVENT(loform,"QueryUnload",this,"ReleaseEvent")
			loForm.Show()
		ENDIF
		
		THIS.SearchChildWindows(_vfp.hWnd, 0)
		
		BINDEVENT(0, WM_CREATE, THIS, "handlewinmsg",4)		
		THIS.Eventloaded = .T.
	ENDPROC

	PROCEDURE releaseevent
		IF THIS.Eventloaded = .T.
			UNBINDEVENT(0, WM_CREATE)
			UNBINDEVENTS(0,WM_DESTROY)
			UNBINDEVENTS(0,WM_SETTEXT)
			UNBINDEVENTS(0,WM_SETFOCUS)
			UNBINDEVENTS(0,WM_WINDOWPOSCHANGED)
			UNBINDEVENTS(0,WM_SHOWWINDOW)
			THIS.oTview = null
		ENDIF
		THIS.Eventloaded = .F.
	ENDPROC

	PROCEDURE removewindow
		LPARAMETERS hWnd
		UNBINDEVENTS(hWnd,WM_DESTROY)
		UNBINDEVENTS(hWnd,WM_SETTEXT)
		UNBINDEVENTS(hWnd,WM_SETFOCUS)
		UNBINDEVENTS(hWnd,WM_WINDOWPOSCHANGED)
		
		THIS.otView.Nodes.Remove(THIS.FindAWindow(hWnd))
		
	ENDPROC

	PROCEDURE searchchildwindows
		LPARAMETERS hWnd, nLevel
		LOCAL hWndChild, cStr, dwStyle
		
		IF LEN(THIS.GetWindowTitle(hWnd))>0 &&AND hWnd != thisform.HWnd
			cStr=SPACE(0x3c) 	&& sizeof WINDOWINFO
			GetWindowInfo(hWnd, @cStr)
			dwStyle=CTOBIN(SUBSTR(cStr,(4*9)+1,4),"4rs")
			IF BITAND(dwStyle ,WS_BORDER) = WS_BORDER
				THIS.AddWindow(hWnd)
			ENDIF
		ENDIF
		
		hWndChild=0
		
		DO WHILE .t.
			hWndChild = FindWindowEx(hWnd,hWndChild,0,0)
			IF hWndCHild = 0
				EXIT
			ENDIF 
			THIS.SearchChildWindows(hWndChild, nLevel+1)	&& Recur
		ENDDO 
		
	ENDPROC

ENDDEFINE

DEFINE CLASS gdititlebar AS wmbase OF "wmhandler.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "wmhandler.h"
	*<DefinedPropArrayMethod>
		*m: drawit
		*p: cstr
		*p: factive
		*p: nsavehwnd
		*p: ofont
		*p: ostrformat
	*</DefinedPropArrayMethod>

	cstr = Europa!
	factive = .T.
	Height = 23
	lcleanalldlls = .T.
	Name = "gdititlebar"
	nsavehwnd = .F.
	ofont = 0
	ostrformat = 0
	Width = 90
	
	PROCEDURE Destroy
		THIS.RemoveDLL("GetWindowDC")
		THIS.RemoveDLL("ReleaseDC")
		THIS.RemoveDLL("GetWindowRect")
		THIS.RemoveDLL("DefWindowProc")
		THIS.RemoveDLL("InvalidateRect")
		THIS.RemoveDLL("GdipCreateLineBrushFromRect")
		
		DODEFAULT()
		
	ENDPROC

	PROCEDURE drawit
		LPARAMETERS hWnd as Integer
		
		LOCAL oGraphics as gpgraphics, hdc, cRect, lcStr
		LOCAL windx,windy,windw,windh
		LOCAL oBrush, oRect
		
		hDc=GetWindowDC(hWnd)
		oGraphics=NEWOBJECT("gpGraphics", HOME()+"ffc\_gdiplus")
		oGraphics.CreateFromHDC(hDC)
		cRect=SPACE(4*4)
		GetWindowRect(hwnd,@cRect)
		windx=CTOBIN(SUBSTR(cRect,1+0*4,4),"4rs")
		windy=CTOBIN(SUBSTR(cRect,1+1*4,4),"4rs")
		windw=CTOBIN(SUBSTR(cRect,1+2*4,4),"4rs")-windx
		windh=CTOBIN(SUBSTR(cRect,1+3*4,4),"4rs")-windy
		
		* Draw string
		IF TYPE("THIS.oHandler.cntEvent.chkCaption")="O" AND THIS.oHandler.cntEvent.chkCaption.Value=.F.
			lcStr=""
		ELSE
			lcStr=THIS.cStr 
		ENDIF
		
		IF this.fActive
			oGraphics.DrawStringA(lcStr,THIS.ofont,;
				NEWOBJECT("gprectangle",HOME()+"ffc\_gdiplus","",windw-250,1,180,125),;
				THIS.oStrFormat,;
				NEWOBJECT("gpsolidbrush",HOME()+"ffc\_gdiplus","",0xff000000 + RGB(0,0,255)))
		ELSE
			oGraphics.DrawStringA(lcStr,this.ofont,;
				NEWOBJECT("gprectangle",HOME()+"ffc\_gdiplus","",windw-250,1,180,125),;
				this.oStrFormat,;
				NEWOBJECT("gpsolidbrush",HOME()+"ffc\_gdiplus","",0xff000000+RGB(255,0,0)))
		ENDIF 
		
		* Draw gradient
		IF TYPE("THIS.oHandler.cntEvent.chkGrad")="O" AND THIS.oHandler.cntEvent.chkGrad.Value=.F.
		ELSE
			nWidth = _vfp.Width-100
			oRect= NEWOBJECT("gprectangle",HOME()+"ffc\_gdiplus","",20,0,nWidth/2,30)
			oBrush=NEWOBJECT("gphatchbrush",HOME()+"ffc\_gdiplus","",4)
			nlBrush=0
			nGradMode=IIF(THIS.fActive, 2, 3)
			GdipCreateLineBrushFromRect(oRect.GdipRectF,0x80ff0000,0x8000ff00,nGradMode,1,@nlBrush)
			oRect.w=nWidth
			oBrush.SetHandle(nlBrush)
			oGraphics.FillRectangle(obrush,oRect)
		ENDIF
		
		ReleaseDC(hWnd, hDC)
		
	ENDPROC

	PROCEDURE handlewinmsg
		LPARAMETERS hWnd as Integer, Msg as Integer, wParam as Integer, lParam as Integer
		
		LOCAL nRetvalue, hDC, lcStr
		nRetvalue=0
		lcStr=""
		
		DO CASE
		CASE msg=WM_NCPAINT
			nRetvalue= CallWindowProc(THIS.noldproc, hWnd, msg, wParam, lParam)
			THIS.Drawit(hWnd)
			IF wParam = 0		&& wparam=1 means entire window needs to be painted
				nRetvalue=1	&& 0 means we processed the msg
			ENDIF
			lcStr = "Paint event"
			
		CASE msg=WM_NCACTIVATE
			THIS.fActive=wParam != 0		&&wParam is TRUE for Active
			nRetvalue= CallWindowProc(THIS.noldproc , hWnd, msg, wParam, lParam)
			THIS.Drawit(hWnd)
			lcStr = "Activate event"
		
		ENDCASE
		
		IF VARTYPE(THIS.oHandler)="O" AND PEMSTATUS(THIS.oHandler,"HandleWinMsg",5)
			THIS.oHandler.HandleWinMsg(lcStr)
		ENDIF
		
		RETURN nRetvalue
		
	ENDPROC

	PROCEDURE init2
		DECLARE integer GetWindowDC IN WIN32API ;
			integer hWnd
		DECLARE integer ReleaseDC IN WIN32API ;
			integer hWnd,	;
			integer hDC
		DECLARE integer GetWindowRect IN win32api	;
			integer hWnd,string @cRect
		DECLARE integer DefWindowProc IN WIN32API ;
			integer hWnd,integer Msg,;
			integer wParam,;
			integer lParam
		DECLARE integer InvalidateRect IN WIN32API ;
			integer hWnd, integer lpRect, integer fErase
		DECLARE integer GdipCreateLineBrushFromRect IN gdiplus.dll ;
			string,;
			integer,integer,;
			integer, integer, integer @
		
		InvalidateRect(0,0,0)
		
		THIS.ofont = NEWOBJECT("gpfont", HOME()+"ffc\_gdiplus", "", "Verdana", 16, 0, 3)
		THIS.oStrFormat = NEWOBJECT("gpstringformat", HOME()+"ffc\_gdiplus")
	ENDPROC

	PROCEDURE loadevent
		THIS.nSavehWnd =   _VFP.hWnd
		BINDEVENT(THIS.nSavehWnd, WM_NCPAINT, THIS, "handlewinmsg")
		BINDEVENT(THIS.nSavehWnd, WM_NCACTIVATE, THIS, "handlewinmsg")
		THIS.eventloaded=.T.
		_SCREEN.Refresh()
	ENDPROC

	PROCEDURE releaseevent
		IF 	THIS.Eventloaded
			UNBINDEVENT(THIS.nSavehWnd , WM_NCPAINT)
			UNBINDEVENT(THIS.nSavehWnd , WM_NCACTIVATE)
		ENDIF	
		THIS.eventloaded=.F.
		_SCREEN.Refresh()
	ENDPROC

ENDDEFINE

DEFINE CLASS mediaevents AS wmbase OF "wmhandler.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "wmhandler.h"
	*<DefinedPropArrayMethod>
		*m: scanfiles
		*m: showbhdr
		*p: cpath
		*p: dwshnotify
		*a: afiles[1,0]
	*</DefinedPropArrayMethod>

	cpath = .F.
	dwshnotify = 0
	Name = "mediaevents"
	
	PROCEDURE Destroy
		THIS.ReleaseEvent()
		
		THIS.RemoveDLL("SHGetPathFromIDList")
		THIS.RemoveDLL("SHChangeNotifyRegister")
		THIS.RemoveDLL("SHChangeNotifyDeregister")
		
		DODEFAULT()
	ENDPROC

	PROCEDURE handlewinmsg
		LPARAMETERS hWnd as Integer, Msg as Integer, wParam as Integer, lParam as Integer
		
		LOCAL lResult, szPath, num, lcStr, lcStr2, lcFiles
		lResult=0
		lcStr = ""
		lcFiles = ""
		THIS.cPath = ""
		
		DO CASE 
		CASE msg = WM_DEVICECHANGE
			DO case
			CASE wParam=DBT_DEVNODES_CHANGED
				lcStr =  "A device has been added or removed from system."
			CASE wParam=DBT_DEVICEARRIVAL
				lcStr = "A device has been inserted and is now available."
			CASE wParam=DBT_DEVICEREMOVECOMPLETE
				lcStr = "Device removal completed"
			ENDCASE
			lResult=CallWindowProc(this.nOldProc,hWnd,msg,wParam,lParam)
		
		CASE msg = WM_USER_SHNOTIFY
			DO CASE
			CASE lParam=SHCNE_DRIVEADD
				lcStr = "Drive added"
			CASE lParam=SHCNE_DRIVEREMOVED
				lcStr = "Drive removed" 
			CASE lParam=SHCNE_MEDIAINSERTED
				lcStr = "Media inserted "
			CASE lParam=SHCNE_MEDIAREMOVED
				lcStr = "Media removed "
			ENDCASE 
		
			num=THIS.Dump(SYS(2600,wParam,4))
			szPath=SPACE(270)
			SHGetPathFromIDList(num,@szPath)
			szPath=LEFT(szPath,AT(CHR(0),szPath)-1)
			THIS.cPath = ALLTRIM(szPath)
			
			lResult=CallWindowProc(this.nOldProc,hWnd,msg,wParam,lParam)
		
		ENDCASE
		
		IF !EMPTY(THIS.cPath)
			DIMENSION THIS.afiles[1]
			STORE "" TO THIS.afiles
			THIS.Scanfiles(THIS.cPath)
			IF !EMPTY(THIS.afiles)
				FOR i = 1 TO ALEN(THIS.afiles)
					lcFiles = lcFiles + THIS.afiles[m.i] + CHR(13) + CHR(10)
				ENDFOR
			ENDIF
		ENDIF
		
		IF EMPTY(THIS.cPath)
			TEXT TO lcStr2 TEXT NOSHOW PRETEXT 6
				<<lcStr>>
			ENDTEXT
		ELSE
		
		TEXT TO lcStr2 TEXT NOSHOW
		<<lcStr>>:
		Path: <<THIS.cPath>>
		Files:
		<<lcFiles>>
		ENDTEXT
		
		ENDIF
		
		IF VARTYPE(THIS.oHandler)="O" AND PEMSTATUS(THIS.oHandler,"HandleWinMsg",5)
			THIS.oHandler.HandleWinMsg(lcStr2)
		ENDIF
		
		RETURN lResult
		
	ENDPROC

	PROCEDURE init2
		DECLARE integer SHGetPathFromIDList IN shell32 ;
		      integer nItemList,;
		      string @szPath
		
		DECLARE integer SHChangeNotifyRegister IN shell32 ;
		      integer hWnd, ;
		      integer fSources, ;
		      integer fEvents, ;
		      integer wMsg,;
		      integer cEntries, ;
		      string @ SEntry 
		
		DECLARE integer SHChangeNotifyDeregister IN shell32 integer
		
	ENDPROC

	PROCEDURE loadevent
		LOCAL lcSEntry
		
		BINDEVENT(_vfp.hWnd, WM_DEVICECHANGE, THIS, "HandleWinMsg")
		BINDEVENT(_vfp.hWnd, WM_USER_SHNOTIFY, THIS, "HandleWinMsg")
		
		lcSEntry = REPLICATE(CHR(0),8)
		
		THIS.dwShNotify = SHChangeNotifyRegister(_vfp.hWnd, ;
		      SHCNE_DISKEVENTS,;
		      SHCNE_MEDIAINSERTED + SHCNE_MEDIAREMOVED + SHCNE_DRIVEADD + SHCNE_DRIVEREMOVED,;
		      WM_USER_SHNOTIFY,1,;
		      @lcSEntry)
		      
		THIS.EventLoaded = .T.
	ENDPROC

	PROCEDURE releaseevent
		IF THIS.EventLoaded
			UNBINDEVENT(_vfp.hWnd, WM_DEVICECHANGE)
			UNBINDEVENT(_vfp.hWnd, WM_USER_SHNOTIFY)
			IF THIS.dwShNotify != 0
				SHChangeNotifyDeregister(THIS.dwShNotify)
			ENDIF 
			THIS.EventLoaded = .F.
		ENDIF
		
	ENDPROC

	PROCEDURE scanfiles
		LPARAMETERS lpcPath AS STRING
		IF PCOUNT() = 0
			RETURN ' '
		ENDIF
		
		LOCAL laFiles[1], ;
			liADIRCnt AS INTEGER, ;
			i AS INTEGER, ;
			lcFname AS STRING, ;
			lcPicProps AS STRING, ;
			lcPic AS STRING
		
		liADIRCnt = ADIR(laFiles, lpcPath + '*.*', 'D')
		
		FOR i = 1 TO liADIRCnt
			IF 'D' $ laFiles[i, 5]
				IF laFiles[i, 1] <> '.'
					THIS.ScanFiles(lpcPath + laFiles[i, 1] + '\')
				ENDIF
			ELSE
				lcFname = lpcPath + laFiles[i, 1]
				IF INLIST(LOWER(JUSTEXT(lcFname)),'jpg','mp3')
					IF !EMPTY(THIS.afiles[1])
						DIMENSION THIS.aFiles[ALEN(THIS.afiles)+1]
					ENDIF			
					THIS.aFiles[ALEN(THIS.afiles)] = lcFname
				ENDIF
			ENDIF
		ENDFOR
	ENDPROC

	PROCEDURE showbhdr
		LPARAMETERS lParam as Integer
		
		LOCAL hdr,size,num,unitmask,flags
		
		hdr = SYS(2600,lParam,12)
		SIZE = THIS.dump(LEFT(hdr,4))
		num = THIS.dump(SUBSTR(hdr,5,4))
		IF num = DBT_DEVTYP_VOLUME
			unitmask = THIS.dump(SUBSTR(SYS(2600,lParam,size),13,4))
			flags = THIS.dump(SUBSTR(SYS(2600,lParam,size),17,2))
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS powerevents AS wmbase OF "wmhandler.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "wmhandler.h"
	Name = "powerevents"
	
	PROCEDURE handlewinmsg
		LPARAMETERS hWnd as Integer, Msg as Integer, wParam as Integer, lParam as Integer
		
		LOCAL nRetvalue,lcStr
		lcStr=""
		nRetvalue=0
		
		DO case
		CASE msg=WM_QUERYENDSESSION
			IF MESSAGEBOX("Would you like to end your Windows session?",36,"Fox Rox!")=6
				nRetvalue= 1
			ELSE
				* 0 means don't allow quit
				nRetvalue=0
			ENDIF
			IF VARTYPE(THIS.oHandler)="O" AND PEMSTATUS(THIS.oHandler,"HandleWinMsg",5)
				THIS.oHandler.HandleWinMsg("End Session")
			ENDIF
			RETURN nRetvalue
		
		CASE msg=WM_POWERBROADCAST
		
			DO CASE 
			CASE wParam=PBT_APMQUERYSUSPEND
				IF MESSAGEBOX("'Stand by' machine?", 36, "Fox Rox!")=6
					nRetvalue = CallWindowProc(this.noldproc,hWnd,msg,wParam,lParam)
				ELSE
					nRetvalue = BROADCAST_QUERY_DENY
				ENDIF
				lcStr = "Request for permission to suspend."
				
			OTHERWISE 
		
				DO CASE
				CASE wParam=PBT_APMBATTERYLOW
					lcStr = "Battery power is low."
				CASE wParam=PBT_APMOEMEVENT
					lcStr = "OEM-defined event occurred."
				CASE wParam=PBT_APMPOWERSTATUSCHANGE
					lcStr = "Power status has changed."			
				CASE wParam=PBT_APMQUERYSUSPENDFAILED
					lcStr = "Suspension request denied."			
				CASE wParam=PBT_APMRESUMEAUTOMATIC
					lcStr = "Operation resuming automatically after event."			
				CASE wParam=PBT_APMRESUMECRITICAL
					lcStr = "Operation resuming after critical suspension."
				CASE wParam=PBT_APMRESUMESUSPEND
					lcStr = "Operation resuming after suspension."
				CASE wParam=PBT_APMSUSPEND
					lcStr = "System is suspending operation."			
				OTHERWISE
					lcStr = "Miscellaneous power broadcast operation."
				ENDCASE
		
				nRetvalue=CallWindowProc(this.noldproc,hWnd,msg,wParam,lParam)
		
			ENDCASE 
		
		OTHERWISE 
			nRetvalue= CallWindowProc(this.noldproc,hWnd,msg,wParam,lParam)
		
		ENDCASE
		
		IF VARTYPE(THIS.oHandler)="O" AND PEMSTATUS(THIS.oHandler,"HandleWinMsg",5)
			THIS.oHandler.HandleWinMsg(lcStr)
		ENDIF
		
		RETURN nRetvalue
		
	ENDPROC

	PROCEDURE loadevent
		BINDEVENT(0, WM_QUERYENDSESSION, THIS, "handlewinmsg")
		BINDEVENT(_VFP.hWnd, WM_POWERBROADCAST, THIS, "handlewinmsg")
		THIS.Eventloaded = .T.
	ENDPROC

	PROCEDURE releaseevent
		IF THIS.EventLoaded
			UNBINDEVENT(0, WM_QUERYENDSESSION)
			UNBINDEVENT(_VFP.hWnd, WM_POWERBROADCAST)
			THIS.Eventloaded = .F.
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS themechange AS wmbase OF "wmhandler.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "wmhandler.h"
	*<DefinedPropArrayMethod>
		*a: asavedlls[1,0]
	*</DefinedPropArrayMethod>

	Name = "themechange"
	
	PROCEDURE handlewinmsg
		LPARAMETERS hWnd as Integer, Msg as Integer, wParam as Integer, lParam as Integer
		
		LOCAL lResult,loword,hiword
		lResult=0
		
		* Note: for WM_THEMECHANGED, MSDN indicates the wParam and lParam 
		* are reserved so can't use them.
		
		IF VARTYPE(THIS.oHandler)="O" AND PEMSTATUS(THIS.oHandler,"HandleWinMsg",5)
			THIS.oHandler.HandleWinMsg("Theme changed...")
		ENDIF
		
		lResult=CallWindowProc(this.nOldProc,hWnd,msg,wParam,lParam)
		
		RETURN lResult
		
	ENDPROC

	PROCEDURE loadevent
		BINDEVENT(_SCREEN.hWnd, WM_THEMECHANGED, THIS, "handlewinmsg")
		THIS.EventLoaded = .T.
	ENDPROC

	PROCEDURE releaseevent
		IF THIS.EventLoaded
			UNBINDEVENT(_SCREEN.hWnd, WM_THEMECHANGED)
			THIS.EventLoaded = .F.
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS wmbase AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "wmhandler.h"
	*<DefinedPropArrayMethod>
		*m: dump
		*m: handlewinmsg
		*m: init2
		*m: loadevent
		*m: releaseevent
		*m: removedll
		*p: eventloaded
		*p: lcleanalldlls
		*p: lkeepdlls
		*p: lloadonstart
		*p: lscreenhwnd
		*p: noldproc
		*p: ohandler
		*a: asavedlls[1,0]
	*</DefinedPropArrayMethod>

	eventloaded = .F.
	lcleanalldlls = .F.
	lkeepdlls = .F.
	lloadonstart = .F.
	lscreenhwnd = .F.
	Name = "wmbase"
	noldproc = 0
	ohandler = .F.
	
	PROCEDURE Destroy
		LOCAL laDLLs, i, lnCount
		DIMENSION 	laDLLs[1]
		
		IF THIS.EventLoaded
			THIS.ReleaseEvent()
		ENDIF
		
		IF THIS.lCleanAllDlls
			lnCount = ADLLS(laDLLs)
			FOR i = 1 TO lnCount
				THIS.RemoveDLL(laDLLs[m.i, 1])
			ENDFOR
		ENDIF
		
		THIS.RemoveDLL("GetWindowLong")
		THIS.RemoveDLL("CallWindowProc")
		
	ENDPROC

	PROCEDURE dump
		LPARAMETERS cStr as String
		
		LOCAL num,i
		num = 0
		FOR i = 1 TO LEN(cStr)
			num=num+(256^(i-1) ) * ASC(SUBSTR(cStr,i,1))
		ENDFOR
		RETURN INT(num)
		
	ENDPROC

	PROCEDURE handlewinmsg
		LPARAMETERS hWnd as Integer, Msg as Integer, wParam as Integer, lParam as Integer
		
	ENDPROC

	PROCEDURE Init
		LOCAL laDLLs
		DIMENSION laDLLs[1]
		ADLLS(laDLLs)
		ACOPY(laDLLs,THIS.aSaveDlls)
		
		DECLARE integer GetWindowLong IN WIN32API ;
			integer hWnd, ;
			integer nIndex
		
		DECLARE integer CallWindowProc IN WIN32API ;
			integer lpPrevWndFunc, ;
			integer hWnd,integer Msg,;
			integer wParam,;
			integer lParam
		
		THIS.nOldProc=GetWindowLong(IIF(THIS.lScreenhWnd, _SCREEN.HWnd, _VFP.HWnd),GWL_WNDPROC)
		
		THIS.Init2()
		
		IF THIS.lLoadOnStart
			THIS.LoadEvent()
		ENDIF
	ENDPROC

	PROCEDURE init2
	ENDPROC

	PROCEDURE loadevent
	ENDPROC

	PROCEDURE releaseevent
	ENDPROC

	PROCEDURE removedll
		LPARAMETERS tcDLLName
		IF THIS.lkeepdlls
			RETURN
		ENDIF
		IF ASCAN(THIS.aSaveDLLs, tcDLLName, -1, -1, 1, 1)=0
			CLEAR DLLS &tcDLLName
		ENDIF
	ENDPROC

ENDDEFINE
