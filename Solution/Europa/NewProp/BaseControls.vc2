*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="basecontrols.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS basecheckbox AS checkbox 
 	*< CLASSDATA: Baseclass="checkbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: lupdatecontrolsourceonchange		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Alignment = 0
	AutoSize = .T.
	BackStyle = 0
	Caption = "Check1"
	FontName = "Tahoma"
	FontSize = 8
	lupdatecontrolsourceonchange = .F.		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
	Name = "basecheckbox"
	Value = .F.
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="lupdatecontrolsourceonchange" type="property" display="lUpdateControlSourceOnChange" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
			if .lUpdateControlSourceOnChange and not empty(.ControlSource) and ;
				not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif .lUpdateControlSourceOnChange ...
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			if .lUpdateControlSourceOnChange and not empty(.ControlSource) and ;
				not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif .lUpdateControlSourceOnChange ...
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecollection AS collection 
 	*< CLASSDATA: Baseclass="collection" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Height = 23
	Name = "buildercollection"
	Width = 23
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS basecombobox AS combobox 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*a: aitems[1,0]		&& An array of items for the RowSource if RowSourceType is set to 5-Array
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	Height = 22
	ItemTips = .T.
	Name = "basecombobox"
	Style = 2
	_memberdata = <VFPData>
		<memberdata name="aitems" type="property" display="aItems"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE Init
		* Initialize aItems.
		
		This.aItems = ''
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif not empty(.ControlSource) ...
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif not empty(.ControlSource) ...
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basecommandbutton AS commandbutton 
 	*< CLASSDATA: Baseclass="commandbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Command1"
	FontName = "Tahoma"
	FontSize = 8
	Height = 23
	Name = "basecommandbutton"
	Width = 75
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS basecontainer AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: enabled_assign
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Name = "basecontainer"
	Style = 3
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE enabled_assign
		lparameters tlEnabled
		This.Enabled = tlEnabled
		This.SetAll('Enabled', tlEnabled)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseeditbox AS editbox 
 	*< CLASSDATA: Baseclass="editbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: validation		&& Custom validation code
		*p: lupdatecontrolsourceonchange		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	IntegralHeight = .T.
	lupdatecontrolsourceonchange = .F.		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
	Name = "baseeditbox"
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="lupdatecontrolsourceonchange" type="property" display="lUpdateControlSourceOnChange" favorites="True"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), call
		* the AnyChange method, and restore the current cursor position in case
		* This.Refresh got called from AnyChange.
		
		local lnSelStart
		with This
			lnSelStart = .SelStart
			if .lUpdateControlSourceOnChange and not empty(.ControlSource) and ;
				not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif .lUpdateControlSourceOnChange ...
			.AnyChange()
			.SelStart = lnSelStart
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif not empty(.ControlSource) ...
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE Valid
		* If we're not canceling, call the Validation method to do the actual
		* validation.
		
		local luReturn
		with This
			if lastkey() <> 27
				luReturn = .Validation()
			else
				luReturn = .T.
			endif lastkey() <> 27
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE validation		&& Custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE When
		* Store the current value into the Tag property so it can be restored if Valid
		* fails.
		
		This.Tag = This.Value
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseform AS form 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: refreshform		&& Refreshes the form with the LockScreen .T.
		*m: restoresettings		&& Restores saved settings from FOXUSER
		*m: savesettings		&& Saves settings to FOXUSER
		*p: cfoxuserid		&& The FOXUSER ID to save/restore settings to
		*p: cfoxusername		&& The FOXUSER NAME to save/restore settings to
		*p: lpersistsizeposition		&& .T. to persist the size and position of the form
		*p: lsavesettings		&& .T. to save and restore settings
		*p: opersist		&& A reference to a FoxResource object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AllowOutput = .F.
	AutoCenter = .T.
	Caption = "Form"
	cfoxuserid = 		&& The FOXUSER ID to save/restore settings to
	cfoxusername = 		&& The FOXUSER NAME to save/restore settings to
	DataSession = 2
	DoCreate = .T.
	FontName = "Tahoma"
	FontSize = 8
	lpersistsizeposition = .T.		&& .T. to persist the size and position of the form
	lsavesettings = .T.		&& .T. to save and restore settings
	Name = "baseform"
	opersist = .NULL.		&& A reference to a FoxResource object
	ShowTips = .T.
	_memberdata = <VFPData>
		<memberdata name="cfoxuserid" type="property" display="cFoxUserID" favorites="True"/>
		<memberdata name="cfoxusername" type="property" display="cFoxUserName" favorites="True"/>
		<memberdata name="lpersistsizeposition" type="property" display="lPersistSizePosition" favorites="True"/>
		<memberdata name="lsavesettings" type="property" display="lSaveSettings" favorites="True"/>
		<memberdata name="opersist" type="property" display="oPersist"/>
		<memberdata name="refreshform" type="method" display="RefreshForm"/>
		<memberdata name="restoresettings" type="method" display="RestoreSettings" favorites="True"/>
		<memberdata name="savesettings" type="method" display="SaveSettings" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Destroy
		* Save the current settings
		
		if This.lSaveSettings
			This.SaveSettings()
		endif This.lSaveSettings
		
		* Nuke member objects.
		
		This.oPersist = .NULL.
		
	ENDPROC

	PROCEDURE Init
		local lcLibrary
		with This
		
		* Restore saved options and the size and position of the form.
		
			if .lSaveSettings
				lcLibrary = 'FoxResource.prg'
				.oPersist = newobject('FoxResource', lcLibrary)
				.RestoreSettings()
			endif .lSaveSettings
		endwith
		
	ENDPROC

	PROCEDURE Load
		* Set up the environment.
		
		set deleted on
		set exact off
		set exclusive off
		set multilocks on
		set safety off
		set talk off
		sys(3054, 0)
		
	ENDPROC

	PROCEDURE refreshform		&& Refreshes the form with the LockScreen .T.
		* Lock for form while refreshing.
		
		This.LockScreen = .T.
		This.Refresh()
		This.LockScreen = .F.
		
	ENDPROC

	PROCEDURE restoresettings		&& Restores saved settings from FOXUSER
		* Restore saved settings from FOXUSER.
		
		with This
			.oPersist.Load(.cFoxUserID, .cFoxUserName)
			if .lPersistSizePosition
				.Top    = max(nvl(.oPersist.Get('Top'),  .Top),  0)
				.Left   = max(nvl(.oPersist.Get('Left'), .Left), 0)
				.Height = nvl(.oPersist.Get('Height'),   .Height)
				.Width  = nvl(.oPersist.Get('Width'),    .Width)
			endif .lPersistSizePosition
		endwith
		
	ENDPROC

	PROCEDURE savesettings		&& Saves settings to FOXUSER
		* Save settings to FOXUSER.
		
		with This
			if .lPersistSizePosition
				.oPersist.Set('Top',    .Top)
				.oPersist.Set('Left',   .Left)
				.oPersist.Set('Height', .Height)
				.oPersist.Set('Width',  .Width)
			endif .lPersistSizePosition
			.oPersist.Save(.cFoxUserID, .cFoxUserName)
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baselabel AS label 
 	*< CLASSDATA: Baseclass="label" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AutoSize = .T.
	BackStyle = 0
	Caption = "Label1"
	FontName = "Tahoma"
	FontSize = 8
	Name = "baselabel"
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS baselabelledbox AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="shpBox" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblBox" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: height_assign
		*m: width_assign
		*p: builder		&& Specifies the builder for this object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	builder = BaseLabelledBoxBuilder.PRG		&& Specifies the builder for this object
	Height = 133
	Name = "baselabelledbox"
	Style = 3
	Width = 168
	_memberdata = <VFPData>
		<memberdata name="builder" type="property" display="Builder"/>
		</VFPData>		&& XML Metadata for customizable properties

	ADD OBJECT 'lblBox' AS baselabel WITH ;
		BackStyle = 1, ;
		Left = 10, ;
		Name = "lblBox", ;
		Style = 3
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'shpBox' AS baseline3d WITH ;
		Height = 124, ;
		Name = "shpBox", ;
		Top = 7, ;
		Width = 166
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="shape" />
	
	PROCEDURE height_assign
		* When the height of the container is resized, resize the shape.
		
		lparameters tnHeight
		This.Height = tnHeight
		This.shpBox.Height = tnHeight - This.shpBox.Top
		
	ENDPROC

	PROCEDURE width_assign
		* When the width of the container is resized, resize the shape.
		
		lparameters tnWidth
		store tnWidth to This.Width, This.shpBox.Width
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseline3d AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackStyle = 0
	Height = 1
	Name = "baseline3d"
	SpecialEffect = 0
	Style = 3
	Width = 100
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties

ENDDEFINE

DEFINE CLASS baselistbox AS listbox 
 	*< CLASSDATA: Baseclass="listbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	IntegralHeight = .T.
	ItemTips = .T.
	Name = "baselistbox"
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif not empty(.ControlSource) ...
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif not empty(.ControlSource) ...
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseoptionbutton AS optionbutton 
 	*< CLASSDATA: Baseclass="optionbutton" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	AutoSize = .T.
	BackStyle = 0
	Caption = "Option1"
	FontName = "Tahoma"
	FontSize = 8
	Name = "baseoptionbutton"
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

ENDDEFINE

DEFINE CLASS baseoptiongroup AS optiongroup 
 	*< CLASSDATA: Baseclass="optiongroup" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderStyle = 0
	ButtonCount = 2
	Height = 46
	MemberClass = "baseoptionbutton"
	MemberClassLibrary = basecontrols.vcx
	Name = "baseoptiongroup"
	Value = 0
	Width = 71
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	Baseoptionbutton1.Left = 5
	Baseoptionbutton1.Name = "Baseoptionbutton1"
	Baseoptionbutton1.Top = 5
	Baseoptionbutton2.Left = 5
	Baseoptionbutton2.Name = "Baseoptionbutton2"
	Baseoptionbutton2.Top = 23
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif not empty(.ControlSource) ...
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif not empty(.ControlSource) ...
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basepage AS page 
 	*< CLASSDATA: Baseclass="page" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	Caption = "Page1"
	FontName = "Tahoma"
	FontSize = 8
	Height = 142
	Name = "basepage"
	Width = 142
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Activate
		* Refresh all controls.
		
		local llLockScreen
		with This
			llLockScreen = Thisform.LockScreen
			if not llLockScreen
				Thisform.LockScreen = .T.
			endif not llLockScreen
			.Refresh()
			if not llLockScreen
				Thisform.LockScreen = .F.
			endif not llLockScreen
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basepageframe AS pageframe 
 	*< CLASSDATA: Baseclass="pageframe" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	ErasePage = .T.
	Height = 250
	MemberClass = "basepage"
	MemberClassLibrary = basecontrols.vcx
	Name = "basepageframe"
	PageCount = 1
	TabStyle = 1
	_memberdata = <VFPData>

		</VFPData>		&& XML Metadata for customizable properties
	Basepage1.Name = "Basepage1"

ENDDEFINE

DEFINE CLASS baseshape AS shape 
 	*< CLASSDATA: Baseclass="shape" Timestamp="" Scale="Pixels" Uniqueid="" />

	BackStyle = 0
	Height = 17
	Name = "baseshape"
	Width = 100

ENDDEFINE

DEFINE CLASS basespinner AS spinner 
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	Height = 22
	Name = "basespinner"
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		do case
		
		* Spinners bound to object properties seem to have a problem when invalid
		* values are entered from the keyboard: the Error method fires with error 1469
		* (property value is out of bounds) with tcMethod being "ControlSource" rather
		* than the Valid method catching it.
		
			case tnError = 1469
				return
		
		* Ignore "property is read-only" errors.
		
			case tnError = 1743
				return
		
		* All other errors get passed on to the form.
		
			otherwise
				Thisform.Error(tnError, This.Name + '.' + tcMethod, tnLine)
		endcase
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), call
		* the AnyChange method, and restore the current cursor position in case
		* This.Refresh got called from AnyChange. Note: if the value is invalid, don't
		* do anything.
		
		local lnSelStart
		with This
			if not between(.Value, .SpinnerLowValue, .SpinnerHighValue)
				nodefault
				return
			endif not between(.Value, ...
			lnSelStart = .SelStart
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				try
					store .Value to (.ControlSource)
				catch
					nodefault
				endtry
			endif not empty(.ControlSource) ...
			.AnyChange()
			.SelStart = lnSelStart
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), call
		* the AnyChange method. Note: if the value is invalid, don't do anything.
		
		with This
			if not between(.Value, .SpinnerLowValue, .SpinnerHighValue)
				nodefault
				return
			endif not between(.Value, ...
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				try
					store .Value to (.ControlSource)
				catch
					nodefault
				endtry
			endif not empty(.ControlSource) ...
			.AnyChange()
		endwith
		
	ENDPROC

ENDDEFINE

DEFINE CLASS basetextbox AS textbox 
 	*< CLASSDATA: Baseclass="textbox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		*m: validation		&& Custom validation code
		*p: lupdatecontrolsourceonchange		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	FontName = "Tahoma"
	FontSize = 8
	Format = "T"
	Height = 22
	lupdatecontrolsourceonchange = .F.		&& .T. to update the control source in InteractiveChange (needed if AnyChange calls Refresh)
	Name = "basetextbox"
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="lupdatecontrolsourceonchange" type="property" display="lUpdateControlSourceOnChange" favorites="True"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE anychange		&& Called from both InteractiveChange and ProgrammaticChange to consolidate handling any changes
		* Abstract method.
		
	ENDPROC

	PROCEDURE InteractiveChange
		* Write the current value to the ControlSource if necessary (otherwise
		* anything called from here can't check the value of our ControlSource), being
		* sure to trim it if it's a character, then call the AnyChange method, and
		* restore the current cursor position in case This.Refresh got called from
		* AnyChange.
		
		local lnSelStart, ;
			luValue
		with This
			lnSelStart = .SelStart
			luValue    = iif(vartype(.Value) = 'C', trim(.Value), .Value)
			if .lUpdateControlSourceOnChange and not empty(.ControlSource) and ;
				not luValue == evaluate(.ControlSource)
				try
					store luValue to (.ControlSource)
				catch
					nodefault
				endtry
			endif .lUpdateControlSourceOnChange ...
			.AnyChange()
			.SelStart = lnSelStart
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		* Prevent Ctrl-0 from inserting a null value.
		
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
		endif tnKeyCode = asc('0') ...
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
			if not empty(.ControlSource) and not .Value == evaluate(.ControlSource)
				store .Value to (.ControlSource)
			endif not empty(.ControlSource) ...
			.AnyChange()
		endwith
		
	ENDPROC

	PROCEDURE Valid
		* If we're not canceling, call the Validation method to do the actual
		* validation.
		
		local luReturn
		with This
			if lastkey() <> 27
				luReturn = .Validation()
			else
				luReturn = .T.
			endif lastkey() <> 27
		endwith
		return luReturn
		
	ENDPROC

	PROCEDURE validation		&& Custom validation code
		* Abstract method
		
	ENDPROC

	PROCEDURE When
		* Store the current value into the Tag property so it can be restored if Valid
		* fails.
		
		This.Tag = This.Value
		
	ENDPROC

ENDDEFINE
